<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="WaterYoungMan&#39;s Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="WaterYoungMan&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="WaterYoungMan">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>WaterYoungMan's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">WaterYoungMan's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/22/FreeRTOS%E6%BA%90%E7%A0%81%E7%B2%BE%E8%AF%BB-xTaskIncrementTick/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WaterYoungMan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WaterYoungMan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/22/FreeRTOS%E6%BA%90%E7%A0%81%E7%B2%BE%E8%AF%BB-xTaskIncrementTick/" class="post-title-link" itemprop="url">FreeRTOS源码精读-xTaskIncrementTick</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-08-22 01:01:17 / Modified: 01:01:50" itemprop="dateCreated datePublished" datetime="2022-08-22T01:01:17+08:00">2022-08-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>将FreeRTOS的系统tick时间xTickCount+1，并检查是否有时间溢出事件；<br>返回值是<code>是否需要切换任务</code>。</p>
<h2 id="调用者"><a href="#调用者" class="headerlink" title="调用者"></a>调用者</h2><p>xTaskIncrementTick有2处被调用：</p>
<ol>
<li>在系统tick中断函数中调用，由xPortSysTickHandler的返回值告知是否需要进行任务切换，如果是通过修改寄存器portNVIC_INT_CTRL_REG来触发PendSV中断，进而切换任务。<br>以ARM_CM3为例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void xPortSysTickHandler( void )</span><br><span class="line">&#123;</span><br><span class="line">    /* The SysTick runs at the lowest interrupt priority, so when this interrupt</span><br><span class="line">     * executes all interrupts must be unmasked.  There is therefore no need to</span><br><span class="line">     * save and then restore the interrupt mask value as its value is already</span><br><span class="line">     * known. */</span><br><span class="line">    portDISABLE_INTERRUPTS();</span><br><span class="line">    &#123;</span><br><span class="line">        /* Increment the RTOS tick. */</span><br><span class="line">        if( xTaskIncrementTick() != pdFALSE )</span><br><span class="line">        &#123;</span><br><span class="line">            /* A context switch is required.  Context switching is performed in</span><br><span class="line">             * the PendSV interrupt.  Pend the PendSV interrupt. */</span><br><span class="line">            portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    portENABLE_INTERRUPTS();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在xTaskResumeAll中调用，有时调度器会被挂起，此时xTickCount并没有及时+1，而是暂存在xPendedCounts中。等到调度器恢复的时候，再补执行。</li>
</ol>
<h2 id="函数源码"><a href="#函数源码" class="headerlink" title="函数源码"></a>函数源码</h2><p>BaseType_t xTaskIncrementTick( void )<br>{<br>    TCB_t * pxTCB;<br>    TickType_t xItemValue;<br>    BaseType_t xSwitchRequired &#x3D; pdFALSE;</p>
<pre><code>/* Called by the portable layer each time a tick interrupt occurs.
 * Increments the tick then checks to see if the new tick value will cause any
 * tasks to be unblocked. */
traceTASK_INCREMENT_TICK( xTickCount );

if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
&#123;
    /* Minor optimisation.  The tick count cannot change in this
     * block. */
    const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;

    /* Increment the RTOS tick, switching the delayed and overflowed
     * delayed lists if it wraps to 0. */
    xTickCount = xConstTickCount;

    if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 &#39;if&#39; does not always evaluate to false as it is looking for an overflow. */
    &#123;
        taskSWITCH_DELAYED_LISTS();
    &#125;
    else
    &#123;
        mtCOVERAGE_TEST_MARKER();
    &#125;

    /* See if this tick has made a timeout expire.  Tasks are stored in
     * the  queue in the order of their wake time - meaning once one task
     * has been found whose block time has not expired there is no need to
     * look any further down the list. */
    if( xConstTickCount &gt;= xNextTaskUnblockTime )
    &#123;
        for( ; ; )
        &#123;
            if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
            &#123;
                /* The delayed list is empty.  Set xNextTaskUnblockTime
                 * to the maximum possible value so it is extremely
                 * unlikely that the
                 * if( xTickCount &gt;= xNextTaskUnblockTime ) test will pass
                 * next time through. */
                xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
                break;
            &#125;
            else
            &#123;
                /* The delayed list is not empty, get the value of the
                 * item at the head of the delayed list.  This is the time
                 * at which the task at the head of the delayed list must
                 * be removed from the Blocked state. */
                pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
                xItemValue = listGET_LIST_ITEM_VALUE( &amp;( pxTCB-&gt;xStateListItem ) );

                if( xConstTickCount &lt; xItemValue )
                &#123;
                    /* It is not time to unblock this item yet, but the
                     * item value is the time at which the task at the head
                     * of the blocked list must be removed from the Blocked
                     * state -  so record the item value in
                     * xNextTaskUnblockTime. */
                    xNextTaskUnblockTime = xItemValue;
                    break; /*lint !e9011 Code structure here is deemed easier to understand with multiple breaks. */
                &#125;
                else
                &#123;
                    mtCOVERAGE_TEST_MARKER();
                &#125;

                /* It is time to remove the item from the Blocked state. */
                listREMOVE_ITEM( &amp;( pxTCB-&gt;xStateListItem ) );

                /* Is the task waiting on an event also?  If so remove
                 * it from the event list. */
                if( listLIST_ITEM_CONTAINER( &amp;( pxTCB-&gt;xEventListItem ) ) != NULL )
                &#123;
                    listREMOVE_ITEM( &amp;( pxTCB-&gt;xEventListItem ) );
                &#125;
                else
                &#123;
                    mtCOVERAGE_TEST_MARKER();
                &#125;

                /* Place the unblocked task into the appropriate ready
                 * list. */
                prvAddTaskToReadyList( pxTCB );

                /* A task being unblocked cannot cause an immediate
                 * context switch if preemption is turned off. */
                #if ( configUSE_PREEMPTION == 1 )
                &#123;
                    /* Preemption is on, but a context switch should
                     * only be performed if the unblocked task has a
                     * priority that is equal to or higher than the
                     * currently executing task. */
                    if( pxTCB-&gt;uxPriority &gt;= pxCurrentTCB-&gt;uxPriority )
                    &#123;
                        xSwitchRequired = pdTRUE;
                    &#125;
                    else
                    &#123;
                        mtCOVERAGE_TEST_MARKER();
                    &#125;
                &#125;
                #endif /* configUSE_PREEMPTION */
            &#125;
        &#125;
    &#125;

    /* Tasks of equal priority to the currently running task will share
     * processing time (time slice) if preemption is on, and the application
     * writer has not explicitly turned time slicing off. */
    #if ( ( configUSE_PREEMPTION == 1 ) &amp;&amp; ( configUSE_TIME_SLICING == 1 ) )
    &#123;
        if( listCURRENT_LIST_LENGTH( &amp;( pxReadyTasksLists[ pxCurrentTCB-&gt;uxPriority ] ) ) &gt; ( UBaseType_t ) 1 )
        &#123;
            xSwitchRequired = pdTRUE;
        &#125;
        else
        &#123;
            mtCOVERAGE_TEST_MARKER();
        &#125;
    &#125;
    #endif /* ( ( configUSE_PREEMPTION == 1 ) &amp;&amp; ( configUSE_TIME_SLICING == 1 ) ) */

    #if ( configUSE_TICK_HOOK == 1 )
    &#123;
        /* Guard against the tick hook being called when the pended tick
         * count is being unwound (when the scheduler is being unlocked). */
        if( xPendedTicks == ( TickType_t ) 0 )
        &#123;
            vApplicationTickHook();
        &#125;
        else
        &#123;
            mtCOVERAGE_TEST_MARKER();
        &#125;
    &#125;
    #endif /* configUSE_TICK_HOOK */

    #if ( configUSE_PREEMPTION == 1 )
    &#123;
        if( xYieldPending != pdFALSE )
        &#123;
            xSwitchRequired = pdTRUE;
        &#125;
        else
        &#123;
            mtCOVERAGE_TEST_MARKER();
        &#125;
    &#125;
    #endif /* configUSE_PREEMPTION */
&#125;
else
&#123;
    ++xPendedTicks;

    /* The tick hook gets called at regular intervals, even if the
     * scheduler is locked. */
    #if ( configUSE_TICK_HOOK == 1 )
    &#123;
        vApplicationTickHook();
    &#125;
    #endif
&#125;

return xSwitchRequired;
</code></pre>
<p>}</p>
<h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><ol>
<li>首先通过变量uxSchedulerSuspended确认当前调度器是否被挂起，如果挂起则直接将xPendedCounts+1然后退出；</li>
<li>如果未挂起则将xTickCount+1；然后检查tick是否出现溢出，如果tick从0xffffffff增加为0，则会执行<code>taskSWITCH_DELAYED_LISTS</code>，对应代码为:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick</span><br><span class="line"> * count overflows. */</span><br><span class="line">#define taskSWITCH_DELAYED_LISTS()                                                \</span><br><span class="line">    &#123;                                                                             \</span><br><span class="line">        List_t * pxTemp;                                                          \</span><br><span class="line">                                                                                  \</span><br><span class="line">        /* The delayed tasks list should be empty when the lists are switched. */ \</span><br><span class="line">        configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );               \</span><br><span class="line">                                                                                  \</span><br><span class="line">        pxTemp = pxDelayedTaskList;                                               \</span><br><span class="line">        pxDelayedTaskList = pxOverflowDelayedTaskList;                            \</span><br><span class="line">        pxOverflowDelayedTaskList = pxTemp;                                       \</span><br><span class="line">        xNumOfOverflows++;                                                        \</span><br><span class="line">        prvResetNextTaskUnblockTime();                                            \</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>taskSWITCH_DELAYED_LISTS函数功能：</p>
<ul>
<li>将溢出delay任务列表和非溢出delay任务列表做一个对调。</li>
<li>xNumOfOverflows +1，即tick溢出次数加1，用于获知当前的tick已经溢出了多少个循环，可以理解为秒钟走了一圈自动触发分针走一格。</li>
<li>prvResetNextTaskUnblockTime()，将下一个任务的解除阻塞时间重新计算。</li>
</ul>
<p>（我是这么理解的：溢出任务列表里面存放的任务应该是下一个tick循环的任务，而当tick清0并进入新一轮的循环之后，原本的溢出任务列表则变成了非溢出任务列表，可以正常比较执行了。）</p>
<ol start="3">
<li>检查完tick溢出后，通过判断xConstTickCount与xNextTaskUnblockTime的大小关系来确认是否有阻塞的任务出现超时，如果有则将这些任务挨个从pxDelayedTaskList取出放到pxReadyTasksLists，并判断是否有优先级比当前任务相同或更高的任务。如果有（且系统配置了允许优先级抢占configUSE_PREEMPTION）则将xSwitchRequired置为true。</li>
<li>检查当前同一优先级的就绪任务是否超过1个，如果有（且系统配置了允许时间分片configUSE_TIME_SLICING）则将xSwitchRequired置为true。</li>
<li>如果xYieldPending为true，则将xSwitchRequired置为true。xYieldPending是一个全局变量，可以理解为一个异步的任务切换通知，当有些函数希望触发任务切换时，不是直接调用切换，而是通过将xYieldPending置位，然后等到systick中断再切换。</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>xTaskIncrementTick的功能：</p>
<ol>
<li>修改系统tick；</li>
<li>判断是否有任务因为tick增加或是别的原因（xYieldPending）而需要解除阻塞，并修改pxReadyTasksLists和pxDelayedTaskList两个任务列表。</li>
<li>综合是否需要进行任务切换并放到函数返回值中，而真正的切换动作由后续其他函数（xPortPendSVHandler）来完成。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/18/FreeRTOS%E8%BF%9B%E9%98%B6-%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E7%9A%84%E6%97%B6%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WaterYoungMan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WaterYoungMan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/18/FreeRTOS%E8%BF%9B%E9%98%B6-%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E7%9A%84%E6%97%B6%E6%9C%BA/" class="post-title-link" itemprop="url">FreeRTOS进阶-任务切换的时机</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-18 22:08:49" itemprop="dateCreated datePublished" datetime="2022-08-18T22:08:49+08:00">2022-08-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-08-22 01:01:35" itemprop="dateModified" datetime="2022-08-22T01:01:35+08:00">2022-08-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>操作系统的任务切换是任务管理中很重要的一环。<br>要了解FreeRTOS的任务切换机制，先要了解以下几个函数：</p>
<table>
<thead>
<tr>
<th>描述</th>
<th>FreeRTOS定义中断函数名</th>
<th>ARM芯片常用适配名</th>
</tr>
</thead>
<tbody><tr>
<td>系统管理调用中断</td>
<td>vPortSVCHandler</td>
<td>SVC_Handler</td>
</tr>
<tr>
<td>挂起系统管理中断</td>
<td>xPortPendSVHandler</td>
<td>PendSV_Handler</td>
</tr>
<tr>
<td>系统滴答定时器中断</td>
<td>xPortSysTickHandler</td>
<td>SysTick_Handler</td>
</tr>
<tr>
<td>触发任务切换</td>
<td>taskYIELD</td>
<td>vPortYield</td>
</tr>
</tbody></table>
<p>这4个函数都是是芯片移植FreeRTOS所需要实现的，在不同的芯片架构上有不同的实现方式。<br>前3个函数都是中断函数，需要在芯片启动时候加载到中断向量表中。</p>
<p>在<a target="_blank" rel="noopener" href="https://www.freertos.org/FAQHelp.html">FreeRTOS官方帮助文档</a>中有这样一段描述：</p>
<blockquote>
<p>Special note to ARM Cortex-M users: ARM Cortex-M3, ARM Cortex-M4 and ARM Cortex-M4F ports need FreeRTOS handlers to be installed on the SysTick, PendSV and SVCCall interrupt vectors. The vector table can be populated directly with the FreeRTOS defined xPortSysTickHandler(), xPortPendSVHandler() and vPortSVCHandler() functions respectively, or, if the interrupt vector table is CMSIS compliant, the following three lines can be added to FreeRTOSConfig.h to map the FreeRTOS function names to their CMSIS equivalents:</p>
</blockquote>
<p>即<code>ARM Cortex-M3, ARM Cortex-M4 and ARM Cortex-M4F</code>中才需要将<code>FreeRTOS handlers</code>放到中断向量表中去执行。换而言之，其他芯片调用这些函数时不一定借助中断。</p>
<h2 id="FreeRTOS-任务切换场合"><a href="#FreeRTOS-任务切换场合" class="headerlink" title="FreeRTOS 任务切换场合"></a>FreeRTOS 任务切换场合</h2><ul>
<li>执行系统调用SVC</li>
<li>系统节拍Systick时钟中断</li>
<li>普通任务使用taskYIELD()强制任务切换，中断服务程序中使用portYIELD_FROM_ISR()强制任务切换</li>
</ul>
<p>通过后面的分析我们可以看到，以上的所有任务切换场合最终是通过同一个函数来执行的，也就是中断函数xPortPendSVHandler。</p>
<h2 id="vPortSVCHandler"><a href="#vPortSVCHandler" class="headerlink" title="vPortSVCHandler"></a>vPortSVCHandler</h2><h3 id="谁调用"><a href="#谁调用" class="headerlink" title="谁调用"></a>谁调用</h3><p>xPortStartScheduler()通常在函数 prvStartFirstTask()中通过调用SVC指令触发SVC中断，而第一个任务的启动就是在SVC中断服务函数中完成的。<br>以ARM_CM3为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">	.align 4</span><br><span class="line">vPortStartFirstTask: .asmfunc</span><br><span class="line">	;/* Use the NVIC offset register to locate the stack. */</span><br><span class="line">	ldr r0, NVICOffsetConst</span><br><span class="line">	ldr r0, [r0]</span><br><span class="line">	ldr r0, [r0]</span><br><span class="line">	;/* Set the msp back to the start of the stack. */</span><br><span class="line">	msr msp, r0</span><br><span class="line">	;/* Clear the bit that indicates the FPU is in use in case the FPU was used</span><br><span class="line">	;before the scheduler was started - which would otherwise result in the</span><br><span class="line">	;unnecessary leaving of space in the SVC stack for lazy saving of FPU</span><br><span class="line">	;registers. */</span><br><span class="line">	mov r0, #0</span><br><span class="line">	msr control, r0</span><br><span class="line">	;/* Call SVC to start the first task. */</span><br><span class="line">	cpsie i</span><br><span class="line">	cpsie f</span><br><span class="line">	dsb</span><br><span class="line">	isb</span><br><span class="line">	svc #0</span><br><span class="line">	.endasmfunc</span><br></pre></td></tr></table></figure>
<p>值得注意的是，并不是所有的芯片架构的prvStartFirstTask都是通过SVC中断来启动第一个任务，我们看下ARM_CM0的代码，里面没有”svc #0”语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void vPortStartFirstTask( void )</span><br><span class="line">&#123;</span><br><span class="line">    /* The MSP stack is not reset as, unlike on M3/4 parts, there is no vector</span><br><span class="line">     * table offset register that can be used to locate the initial stack value.</span><br><span class="line">     * Not all M0 parts have the application vector table at address 0. */</span><br><span class="line">    __asm volatile (</span><br><span class="line">        &quot;	.syntax unified				\n&quot;</span><br><span class="line">        &quot;	ldr  r2, pxCurrentTCBConst2	\n&quot;/* Obtain location of pxCurrentTCB. */</span><br><span class="line">        &quot;	ldr  r3, [r2]				\n&quot;</span><br><span class="line">        &quot;	ldr  r0, [r3]				\n&quot;/* The first item in pxCurrentTCB is the task top of stack. */</span><br><span class="line">        &quot;	adds r0, #32					\n&quot;/* Discard everything up to r0. */</span><br><span class="line">        &quot;	msr  psp, r0					\n&quot;/* This is now the new top of stack to use in the task. */</span><br><span class="line">        &quot;	movs r0, #2					\n&quot;/* Switch to the psp stack. */</span><br><span class="line">        &quot;	msr  CONTROL, r0				\n&quot;</span><br><span class="line">        &quot;	isb							\n&quot;</span><br><span class="line">        &quot;	pop  &#123;r0-r5&#125;					\n&quot;/* Pop the registers that are saved automatically. */</span><br><span class="line">        &quot;	mov  lr, r5					\n&quot;/* lr is now in r5. */</span><br><span class="line">        &quot;	pop  &#123;r3&#125;					\n&quot;/* Return address is now in r3. */</span><br><span class="line">        &quot;	pop  &#123;r2&#125;					\n&quot;/* Pop and discard XPSR. */</span><br><span class="line">        &quot;	cpsie i						\n&quot;/* The first task has its context and interrupts can be enabled. */</span><br><span class="line">        &quot;	bx   r3						\n&quot;/* Finally, jump to the user defined task code. */</span><br><span class="line">        &quot;								\n&quot;</span><br><span class="line">        &quot;	.align 4					\n&quot;</span><br><span class="line">        &quot;pxCurrentTCBConst2: .word pxCurrentTCB	  &quot;</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>FreeRTOS/Source/portable</code>中可以看到，SVC调用代码还可以是<code>svc %0</code>，<code>svc 0</code></p>
<h3 id="发生了什么"><a href="#发生了什么" class="headerlink" title="发生了什么"></a>发生了什么</h3><p>该中断的优先级为1，由SVC指令触发。触发后如果没有更高优先级的中断存在，就会根据中断向量表，跳转到vPortSVCHandler函数。</p>
<h3 id="为什么要设计SVC中断"><a href="#为什么要设计SVC中断" class="headerlink" title="为什么要设计SVC中断"></a>为什么要设计SVC中断</h3><p>SVC中断中需要修改寄存器，根据一些网上的资料，在部分ARM芯片上，只有特权模式下才能修改这些寄存器，而进入中断会自动切换到特权模式。因此我怀疑这个SVC的设计和ARM的权限设计有关，即用户模式下的应用需要借助高权限的中断来完成一些操作系统任务。</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>以ARM_CM3为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void vPortSVCHandler( void )</span><br><span class="line">&#123;</span><br><span class="line">    __asm volatile (</span><br><span class="line">        &quot;	ldr	r3, pxCurrentTCBConst2		\n&quot;/* Restore the context. */</span><br><span class="line">        &quot;	ldr r1, [r3]					\n&quot;/* Use pxCurrentTCBConst to get the pxCurrentTCB address. */</span><br><span class="line">        &quot;	ldr r0, [r1]					\n&quot;/* The first item in pxCurrentTCB is the task top of stack. */</span><br><span class="line">        &quot;	ldmia r0!, &#123;r4-r11&#125;				\n&quot;/* Pop the registers that are not automatically saved on exception entry and the critical nesting count. */</span><br><span class="line">        &quot;	msr psp, r0						\n&quot;/* Restore the task stack pointer. */</span><br><span class="line">        &quot;	isb								\n&quot;</span><br><span class="line">        &quot;	mov r0, #0 						\n&quot;</span><br><span class="line">        &quot;	msr	basepri, r0					\n&quot;</span><br><span class="line">        &quot;	orr r14, #0xd					\n&quot;</span><br><span class="line">        &quot;	bx r14							\n&quot;</span><br><span class="line">        &quot;									\n&quot;</span><br><span class="line">        &quot;	.align 4						\n&quot;</span><br><span class="line">        &quot;pxCurrentTCBConst2: .word pxCurrentTCB				\n&quot;</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="xPortPendSVHandler"><a href="#xPortPendSVHandler" class="headerlink" title="xPortPendSVHandler"></a>xPortPendSVHandler</h2><h3 id="为什么要设计PendSV中断"><a href="#为什么要设计PendSV中断" class="headerlink" title="为什么要设计PendSV中断"></a>为什么要设计PendSV中断</h3><p>SV 的全称是 Supervisor，翻译为“监督者”，指的是系统管理。<br>PendSV中断服务程序的功能是完成任务切换。即找到最高优先级的就绪任务，然后让这个任务接下来能获得CPU运行权。<br>不在Systick中执行任务切换，是为了避免任务切换占用太多了时间，导致其他中断阻塞。<br>PendSV的优先级为最低，也就是说如果有其他更高优先级的中断，则需要将其他中断执行完之后再执行xPortPendSVHandler，为什么这么设计呢？因为中断的优先级大于所有任务。而任务切换的最终结果只是去决定下一个执行的任务是哪个，那么自然中断切换的优先级应该放到所有中断的最低档，却又比所有的任务优先级高。。</p>
<h3 id="PendSV中断如何触发"><a href="#PendSV中断如何触发" class="headerlink" title="PendSV中断如何触发"></a>PendSV中断如何触发</h3><p>PendSV可以由xPortSysTickHandler或vPortSVCHandler触发</p>
<h2 id="xPortSysTickHandler"><a href="#xPortSysTickHandler" class="headerlink" title="xPortSysTickHandler"></a>xPortSysTickHandler</h2><p>在系统节拍时钟中断服务函数中:<br>首先会将tick计数器的值+1，同时查看是否有任务解除阻塞，如果有任务解除阻塞的话，则使能PendSV中断。<br>以ARM_CM3为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void xPortSysTickHandler( void )</span><br><span class="line">&#123;</span><br><span class="line">    /* The SysTick runs at the lowest interrupt priority, so when this interrupt</span><br><span class="line">     * executes all interrupts must be unmasked.  There is therefore no need to</span><br><span class="line">     * save and then restore the interrupt mask value as its value is already</span><br><span class="line">     * known. */</span><br><span class="line">    portDISABLE_INTERRUPTS();</span><br><span class="line">    &#123;</span><br><span class="line">        /* Increment the RTOS tick. */</span><br><span class="line">        if( xTaskIncrementTick() != pdFALSE )</span><br><span class="line">        &#123;</span><br><span class="line">            /* A context switch is required.  Context switching is performed in</span><br><span class="line">             * the PendSV interrupt.  Pend the PendSV interrupt. */</span><br><span class="line">            portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    portENABLE_INTERRUPTS();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="taskYIELD"><a href="#taskYIELD" class="headerlink" title="taskYIELD"></a>taskYIELD</h2><p>在需要手动切换任务的场景，就会调用taskYIELD()，最终会执行宏portYIELD()。<br>以ARM_CM3为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#define portYIELD()                                 \</span><br><span class="line">&#123;                                                   \</span><br><span class="line">    /* Set a PendSV to request a context switch. */ \</span><br><span class="line">    portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT; \</span><br><span class="line">                                                    \</span><br><span class="line">    /* Barriers are normally not required but do ensure the code is completely \</span><br><span class="line">     * within the specified behaviour for the architecture. */ \</span><br><span class="line">    __asm volatile ( &quot;dsb&quot; ::: &quot;memory&quot; );                     \</span><br><span class="line">    __asm volatile ( &quot;isb&quot; );                                  \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在tasks.c中可以看到，xTaskResumeAll、vTaskResume、prvIdleTask这样的函数都会调用taskYIELD。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>systick中断、任务操作函数、某些系统调用都会触发任务切换。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/16/FreeRTOS%E5%9F%BA%E7%A1%80-%E4%BA%92%E6%96%A5%E9%94%81%E4%B8%8E%E9%80%92%E5%BD%92%E4%BA%92%E6%96%A5%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WaterYoungMan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WaterYoungMan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/16/FreeRTOS%E5%9F%BA%E7%A1%80-%E4%BA%92%E6%96%A5%E9%94%81%E4%B8%8E%E9%80%92%E5%BD%92%E4%BA%92%E6%96%A5%E9%94%81/" class="post-title-link" itemprop="url">FreeRTOS基础-互斥锁与递归互斥锁</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-16 23:26:00" itemprop="dateCreated datePublished" datetime="2022-08-16T23:26:00+08:00">2022-08-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-08-17 00:06:47" itemprop="dateModified" datetime="2022-08-17T00:06:47+08:00">2022-08-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>互斥锁是一种用于多线程编程中，防止两条线程同时对同一公共资源（比如全域变量）进行读写的机制。<br>该机制通过将代码切片成一个一个的临界区域（critical section）达成，临界区域指的是一块对公共资源进行存取的代码，并非一种机制或是算法。一个程序、进程、线程可以拥有多个临界区域，但是并不一定会应用互斥锁。</p>
<h2 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h2><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static SemaphoreHandle_t xSemaphore = NULL;</span><br><span class="line">// 1.创建互斥锁</span><br><span class="line">xSemaphore = xSemaphoreCreateMutex();</span><br><span class="line"></span><br><span class="line">// 2.获取互斥锁</span><br><span class="line">xSemaphoreTake(xSemaphore, portMAX_DELAY);</span><br><span class="line"></span><br><span class="line">// 3.释放互斥锁</span><br><span class="line">xSemaphoreGive(xSemaphore);</span><br><span class="line"></span><br><span class="line">// 4.删除互斥锁</span><br><span class="line">vSemaphoreDelete(xSemaphore);</span><br></pre></td></tr></table></figure>


<h3 id="递归互斥锁"><a href="#递归互斥锁" class="headerlink" title="递归互斥锁"></a>递归互斥锁</h3><p>只有将宏configUSE_RECURSIVE_MUTEXES定义为1才会编译这些函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static SemaphoreHandle_t xSemaphore = NULL;</span><br><span class="line">// 1.创建递归互斥锁</span><br><span class="line">xSemaphoreCreateRecursiveMutex();</span><br><span class="line"></span><br><span class="line">// 2.获取递归互斥锁</span><br><span class="line">xSemaphoreTakeRecursive(xSemaphore, portMAX_DELAY);</span><br><span class="line"></span><br><span class="line">// 3.释放递归互斥锁</span><br><span class="line">xSemaphoreGiveRecursive(xSemaphore);</span><br><span class="line"></span><br><span class="line">// 4.删除递归互斥锁</span><br><span class="line">vSemaphoreDelete(xSemaphore);</span><br></pre></td></tr></table></figure>

<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="互斥锁与递归互斥锁的区别"><a href="#互斥锁与递归互斥锁的区别" class="headerlink" title="互斥锁与递归互斥锁的区别"></a>互斥锁与递归互斥锁的区别</h3><p>已经获取递归互斥量的任务可以重复获取该递归互斥量。使用xSemaphoreTakeRecursive() 函数成功获取几次递归互斥量，就要使用xSemaphoreGiveRecursive()函数返还几次，在此之前递归互斥量都处于无效状态。比如，某个任务成功获取5次递归互斥量，那么在它没有返还5次该递归互斥量之前，这个互斥量对别的任务无效。</p>
<h3 id="互斥锁与信号量"><a href="#互斥锁与信号量" class="headerlink" title="互斥锁与信号量"></a>互斥锁与信号量</h3><p>通过FreeRTOS源码可看到，互斥锁和递归互斥锁实质上也是信号量，而信号量实质上也是队列。</p>
<h3 id="互斥锁与二值信号量的区别"><a href="#互斥锁与二值信号量的区别" class="headerlink" title="互斥锁与二值信号量的区别"></a>互斥锁与二值信号量的区别</h3><p>我们知道，二值信号量也可以用户保护某些公共资源不被多个线程在同一时刻使用。但是如果用互斥锁来实现，则在发生“优先级翻转”时，可以通过“优先级继承”来帮助低优先级线程提前执行，从而释放公共资源。</p>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/zh/%E4%BA%92%E6%96%A5%E9%94%81">https://zh.m.wikipedia.org/zh/%E4%BA%92%E6%96%A5%E9%94%81</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhzht19861011/article/details/51606068">https://blog.csdn.net/zhzht19861011/article/details/51606068</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/14/FreeRTOS-%E5%9C%A8Linux%E4%B8%8A%E4%BB%BF%E7%9C%9FFreeRTOS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WaterYoungMan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WaterYoungMan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/14/FreeRTOS-%E5%9C%A8Linux%E4%B8%8A%E4%BB%BF%E7%9C%9FFreeRTOS/" class="post-title-link" itemprop="url">FreeRTOS-在Linux上仿真FreeRTOS</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-08-14 23:43:05 / Modified: 23:44:14" itemprop="dateCreated datePublished" datetime="2022-08-14T23:43:05+08:00">2022-08-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在esp-idf中看到了<code>components/mdns/host_test/components/freertos_linux</code>这个组件，看了下代码发现有点类似于在linux下直接模拟FreeRTOS的接口，网上找了一下发现FreeRTOS官方的工程已经支持linux模拟。</p>
<h2 id="操作示例"><a href="#操作示例" class="headerlink" title="操作示例"></a>操作示例</h2><p>1.以下是官方网站，上面也有步骤教程：<br><a target="_blank" rel="noopener" href="https://www.freertos.org/FreeRTOS-simulator-for-Linux.html">https://www.freertos.org/FreeRTOS-simulator-for-Linux.html</a></p>
<p>2.下载FreeRTOS工程<br><code>https://github.com/FreeRTOS/FreeRTOS</code></p>
<p>3.在Linux上编译执行（相关的gcc，make，库依赖可参考官网说明安装）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd FreeRTOS/Demo/Posix_GCC</span><br><span class="line">make</span><br><span class="line">cd build</span><br><span class="line">./posix_demo</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/08/11/FOdqewa6Pzx9AG8.png" alt="image.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WaterYoungMan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WaterYoungMan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">操作系统-内存动态分配算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-08-14 23:25:18 / Modified: 23:43:20" itemprop="dateCreated datePublished" datetime="2022-08-14T23:25:18+08:00">2022-08-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>逻辑地址映射到物理地址，当我们给程序分配物理地址空间时，会给予一个程序随机连续的一段物理地址空间。那么就会出现内存碎片的问题。</p>
<p>内存碎片问题：即空闲内存不能被利用，分为两种：</p>
<ul>
<li>外部碎片(在分配单元间的未使用的内存)</li>
<li>内部碎片(在分配单元中未使用的内存)</li>
</ul>
<h2 id="首次适配算法"><a href="#首次适配算法" class="headerlink" title="首次适配算法"></a>首次适配算法</h2><p>每次都从低地址开始查找，找到第一个能满足大小的空闲分区。</p>
<h3 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h3><ul>
<li>按地址排序的空闲块列表</li>
<li>分配需要寻找一个合适的分区</li>
<li>重新分配需要检查，看是自由分区能够合并于相邻的空闲分区</li>
</ul>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>简单</li>
<li>易于产生更大空闲块，向着地址空间的结尾</li>
</ul>
<h3 id="缺点-："><a href="#缺点-：" class="headerlink" title="缺点 ："></a>缺点 ：</h3><ul>
<li>外部碎片</li>
<li>不确定性</li>
</ul>
<h2 id="最优适配算法"><a href="#最优适配算法" class="headerlink" title="最优适配算法"></a>最优适配算法</h2><p>最优适配算法是从全部空闲区中找出能满足作业要求的、且大小最小的空闲分区的一种计算方法，这种方法能使碎片尽量小。</p>
<h3 id="需求：-1"><a href="#需求：-1" class="headerlink" title="需求："></a>需求：</h3><ul>
<li>按尺寸排列空闲块列表</li>
<li>分配需要寻找一个合适的分区</li>
<li>重分配需要搜索及合并相邻的空闲分区（若有）</li>
</ul>
<h3 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>避免分割大的空闲块</li>
<li>最小化外部碎片产生的尺寸</li>
<li>当大部分分配是小尺寸时非常有效</li>
</ul>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li>外部碎片</li>
<li>重分配慢</li>
<li>易产生很多没用的微小碎片</li>
</ul>
<h2 id="最差适配算法"><a href="#最差适配算法" class="headerlink" title="最差适配算法"></a>最差适配算法</h2><p>为了解决最佳适应算法的问题——即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。</p>
<h3 id="需求：-2"><a href="#需求：-2" class="headerlink" title="需求："></a>需求：</h3><ul>
<li>按尺寸排列空闲块列表</li>
<li>分配很快（获得最大的分区）</li>
<li>重分配需要合并相邻的空闲分区，若有，然后调整空闲块列表</li>
</ul>
<h3 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>当大部分分配是中等尺寸时效果最好</li>
<li>避免产生太多的微小碎片</li>
</ul>
<h3 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li>重分配慢</li>
<li>外部碎片</li>
<li>易于分割大的空闲块，以致需要大分区时，无法满足需要。</li>
</ul>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://my.oschina.net/u/4135649/blog/4332891">https://my.oschina.net/u/4135649/blog/4332891</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6942662689546059807#heading-0">https://juejin.cn/post/6942662689546059807#heading-0</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WaterYoungMan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WaterYoungMan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">操作系统-调度算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-08-14 12:13:05 / Modified: 23:43:44" itemprop="dateCreated datePublished" datetime="2022-08-14T12:13:05+08:00">2022-08-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h2><p>CPU利用率：CPU忙碌的时间&#x2F;总时间</p>
<p>系统吞吐量：单位时间内总共完成多少道作业&#x2F;进程</p>
<p>周转时间：作业完成的时刻 - 作业提交的时刻，也等于 作业&#x2F;进程等待时间 + 作业&#x2F;进程运行时间。</p>
<p>周转时间 &#x3D; 作业在作业队列等待被高级调度的时间 + 进程在就绪队列等待被低级调度的时间 + 进程运行的时间 + 进程等待IO操作的时间。</p>
<p>平均周转时间：各作业周转时间之和 &#x2F; 作业数</p>
<p>带权周转时间：作业周转时间 &#x2F; 作业实际运行的时间，带权周转时间 &gt;&#x3D; 1，越小越好。</p>
<p>平均带权周转时间：各作业带权周转时间之和 &#x2F; 作业数</p>
<p>等待时间： 进程&#x2F;作业 处于等待CPU状态的时间之和。等于周转时间 - 运行时间。</p>
<p>响应时间：从用户提交作业请求到该作业第一次占有CPU的时间。</p>
<h2 id="批处理时代算法"><a href="#批处理时代算法" class="headerlink" title="批处理时代算法"></a>批处理时代算法</h2><h3 id="先来先服务算法-FCFS"><a href="#先来先服务算法-FCFS" class="headerlink" title="先来先服务算法(FCFS)"></a>先来先服务算法(FCFS)</h3><p>First Come First Serve，按照进程进入就绪队列的先后顺序调度并分配处理机执行。先来先服务调度算法是一种非抢占式的算法，先进入就绪队列的进程，先分配处理机运行。一旦一个进程占有了处理机，它就一直运行下去，直到该进程完成工作或者因为等待某事件发生而不能继续运行时才释放处理机。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>有利于长作业以及 CPU 繁忙的作业</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>不利于短作业以及 I&#x2F;O 繁忙的作业</li>
</ul>
<h3 id="最短作业优先算法-SJF"><a href="#最短作业优先算法-SJF" class="headerlink" title="最短作业优先算法(SJF)"></a>最短作业优先算法(SJF)</h3><p>Shortest Job First, SJF。从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li>比 FCFS 改善平均周转时间和平均带权周转时间，缩短作业的等待时间；</li>
<li>提高系统的吞吐量；</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>对长作业非常不利，可能长时间得不到执行；</li>
<li>未能依据作业的紧迫程度来划分执行的优先级；</li>
<li>难以准确估计作业（进程）的执行时间，从而影响调度性能。</li>
</ul>
<h3 id="高响应比优先算法-HRRN"><a href="#高响应比优先算法-HRRN" class="headerlink" title="高响应比优先算法(HRRN)"></a>高响应比优先算法(HRRN)</h3><p>Highest Response Ratio Next，HRRN。<br>前面的先来先服务算法(FCFS)对长作业有利，最短作业优先算法(SJF)对短作业有利。却都达不到对长作业和短作业调度的平衡。<br>进程(任务)的两个重要属性：等待时间和要求服务时间。<br>高响应比优先算法试图达到这个属性之间的平衡，让等待时间长+要求服务时间短（就是短作业）的任务更容易被选中。</p>
<p>有一个量化的公式：响应比 &#x3D; （等待时间+要求服务时间）&#x2F; 要求服务时间。<br>响应比高的算法会先执行。</p>
<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><p>综合考虑了等待时间和运行时间（要求服务时间）。等待时间相同时，要求服务时间短的优先 ；要求服务时间相同时，等待时间长的优先 。对于长作业来说，随着等待时间越来越久，其响应比也会 越来越大，从而避免了长作业饥饿的问；</p>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><p>没有考虑到作业&#x2F;进程的紧急程度；如果要求服务的时间预估错误，则高响应比算法不再有效。</p>
<h2 id="并发时代算法"><a href="#并发时代算法" class="headerlink" title="并发时代算法"></a>并发时代算法</h2><h3 id="时间片轮转算法-RR"><a href="#时间片轮转算法-RR" class="headerlink" title="时间片轮转算法(RR)"></a>时间片轮转算法(RR)</h3><p>Round Robin，RR。在这个算法里，将系统中所有的就绪进程按照FCFS原则，排成一个队列。每次调度时将CPU分派给队首进程，让其执行一个时间片。时间片的长度从几个ms到几百ms，在一个时间片结束时，发生时钟中断。调度程序据此暂停当前进程的执行，将其送到就绪队列的末尾，并通过上下文切换执行当前的队首进程。进程可以未使用完一个时间片，就出让CPU（如阻塞）。</p>
<p>这个算法存在一个问题，时间片的长度怎么设计？</p>
<ul>
<li>时间片越短，固定时间里可运行的进程就越多，可CPU说过，切换进程是要消耗他不少指令周期的，时间片过短会导致大量CPU资源浪费在切换上下文上。</li>
<li>时间片过长，长到一个时间片能执行完每一个单独的任务时，就相当于退化为FCFS算法。这也意味着短交互指令响应会变慢。</li>
</ul>
<h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><p>公平；每个进程响应快；不会导致饥饿；</p>
<h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><p>没有考虑到作业&#x2F;进程的紧急程度；时间片大小需要足够合适，否则会降低进程运行效率。</p>
<h3 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h3><p>前面那个时间片轮转调度过于公平，实际上进程的任务的紧急程度是不一样的，有些进程可以在后台慢慢运算，而有些进程急于给用户响应。<br>所以在时间片轮转的基础上，加上了优先级，调度程既希望给每个进程轮转调度，又希望每次轮转尽可能选择高优先级的进程。</p>
<p>每个进程将被赋予一个优先级，自己根据自己的情况确定优先级数值，但是，用户进程的优先级不准高于内核进程的优先级。切换程序的时候，先从优先级1的队列里选择一个进程，如果优先级1队列为空，才会选择优先级2中的进程，以此类推。</p>
<h4 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h4><p>区分进程的紧急程度，根据优先级决定调度顺序；也可以灵活设定CPU&#x2F;IO密集型进程的优先级；</p>
<h4 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h4><p>若源源不断地有高优先级进程到来，则可能导致饥饿。</p>
<h3 id="多级反馈队列调度算法-MFQ"><a href="#多级反馈队列调度算法-MFQ" class="headerlink" title="多级反馈队列调度算法(MFQ)"></a>多级反馈队列调度算法(MFQ)</h3><p>Multilevel Feedback Queue，MFQ。</p>
<ul>
<li>「多级」就是就绪队列不再是一个，而是多个，每个队列优先级不同，时间片也不同。</li>
<li>「反馈」意味着这个算法是动态的，根据当前进程的变化而变化。</li>
</ul>
<p>有多个队列，每个队列优先级不同，队列优先级越高，时间片越短。<br>新来的进程会先进入最高优先级队列，如果在一级队列的时间片内没有执行完，该进程会被向下送入二级队列，以此类推，直至进程执行完成。<br>只有高级队列为空时，才执行低级队列中的进程。假如正在执行低级队列中的进程，此时高级队列中来了新进程，则停止运行当前进程，转而运行高级队列中的进程。</p>
<p>可以发现，这个算法兼顾了公平和效率。</p>
<ul>
<li>短作业进入高级队列可以很快被执行完毕而不会进入低级队列，保证了短作业响应速度。</li>
<li>长作业可能在高级队列的时间片内执行不完，会被移入低级队列，虽然低级队列的优先权低，但时间片长，也就是说，低级队列被选中执行的概率相对小，但一旦被选中则执行的时间长。</li>
</ul>
<h4 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h4><p>该算法同时使用了FCFS、RR、SPF 和优先级调度算法，也集合了他们的优点，即公平、快速响应、短进程快速完成（他们可能在第一级队列就完成了）、区分进程紧急程度、灵活调整系统对CPU&#x2F;IO密集型进程的偏好；</p>
<h4 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h4><p>可能导致饥饿。如不停有新进程进入1级队列，而且这些进程都是短进程，在1个时间片内就可以完成，此时下级队列的进程就一直无法持有CPU。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>批处理算法和并发算法的最大区别是：一个任务是连续执行还是按照时间片分割的。</li>
<li>进程调度的策略至关重要，调度算法指标总结来说就是公平与效率的取舍。各种调度算法各有优势，在不同场景不同系统选择适当的调度策略。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/13/FreeRTOS%E5%9F%BA%E7%A1%80-%E4%BA%8C%E5%80%BC%E4%BF%A1%E5%8F%B7%E9%87%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WaterYoungMan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WaterYoungMan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/13/FreeRTOS%E5%9F%BA%E7%A1%80-%E4%BA%8C%E5%80%BC%E4%BF%A1%E5%8F%B7%E9%87%8F/" class="post-title-link" itemprop="url">FreeRTOS基础-二值信号量</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-13 23:25:55" itemprop="dateCreated datePublished" datetime="2022-08-13T23:25:55+08:00">2022-08-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-08-16 23:48:53" itemprop="dateModified" datetime="2022-08-16T23:48:53+08:00">2022-08-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>信号量是对象大小为0的队列，二值信号量是队列长度为1的信号量。<br>二值信号量一般用于多任务间同步信息，有时也被当做互斥锁来使用。</p>
<h2 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static SemaphoreHandle_t xSemaphore = NULL;</span><br><span class="line">// 1.创建信号量</span><br><span class="line">// FreeRTOS v8.x以后版本推荐使用，创建后信号量初始值为“空”</span><br><span class="line">xSemaphore = xSemaphoreCreateBinary();</span><br><span class="line"></span><br><span class="line">// FreeRTOS v7.x以前版本也有这样的写法，创建后信号量初始值为“非空”（当前版本还保留此接口，但不推荐再使用）：</span><br><span class="line">vSemaphoreCreateBinary(xSemaphore);</span><br><span class="line"></span><br><span class="line">// 2.接收信号量</span><br><span class="line">xSemaphoreTake(xSemaphore, portMAX_DELAY);</span><br><span class="line"></span><br><span class="line">// 3.发送信号量</span><br><span class="line">// 在中断函数中和非中断函数中发送信号量的接口不一样，可用__get_IPSR()返回值判断：</span><br><span class="line"></span><br><span class="line">// 非中断中发送</span><br><span class="line">xSemaphoreGive(xSemaphore);</span><br><span class="line"></span><br><span class="line">// 中断中发送</span><br><span class="line">signed portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;</span><br><span class="line">xSemaphoreGiveFromISR(xSemaphore, &amp;xHigherPriorityTaskWoken);</span><br><span class="line">portEND_SWITCHING_ISR(xHigherPriorityTaskWoken);</span><br><span class="line"></span><br><span class="line">// 4.删除信号量</span><br><span class="line">vSemaphoreDelete(xSemaphore);</span><br></pre></td></tr></table></figure>

<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="队列操作"><a href="#队列操作" class="headerlink" title="队列操作"></a>队列操作</h3><p>take相当于把队列长度（uxMessagesWaiting）+1；</p>
<ul>
<li>如果队列为空，take将会阻塞。</li>
<li>如果队列为满，队列长度-1；</li>
</ul>
<p>give相当于把队列长度-1；</p>
<ul>
<li>如果队列为空，队列长度+1；</li>
<li>如果队列为满，give操作返回失败；</li>
</ul>
<h3 id="多任务竞争"><a href="#多任务竞争" class="headerlink" title="多任务竞争"></a>多任务竞争</h3><p>当多个任务同时阻塞在同一个信号量上，优先级高的任务会获得信号量</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/13/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AB%BA%E5%8F%AF%E6%A1%A2%E4%BC%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WaterYoungMan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WaterYoungMan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/13/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AB%BA%E5%8F%AF%E6%A1%A2%E4%BC%A0/" class="post-title-link" itemprop="url">读书笔记-竺可桢传</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-08-13 23:23:07 / Modified: 23:23:39" itemprop="dateCreated datePublished" datetime="2022-08-13T23:23:07+08:00">2022-08-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>阅读时间：2022.07.30。<br>这本书是去威海旅游的时候在路边书店买下的。<br>竺可桢先生是我们的老校长，我在校时便深受他的思想影响。<br>读完传记，得以窥见竺老校长的一生。我感慨于在二十世纪初那个年代成长起来的人，很多都拥有着强烈的使命感，有真正的民族主义和爱国情怀，对同胞充满了大爱。可能是遇到了太多的苦难，他们也特别珍惜来之不易的学习机会。一批批青年在艰苦的环境中成长，最终成为在各行各业功勋卓著的栋梁之才。反观现在和平年代，物质和享乐充斥着人们的生活，让大多数人无暇去思考。而青年人也普遍缺乏对社会的认识，缺乏对历史的了解。贫富差距的增大，房价的高昂甚至也逐渐消磨了年轻人的奋斗激情。整个社会仿佛一个巨大的机器，在按照一部分人设置的轨道运行。再看看日本和韩国的现状，经济下行，社会严重分化，没有活力。希望中国能从这个轨道跳脱出来，避免重蹈日韩的覆辙。</p>
<h2 id="严谨的学问精神"><a href="#严谨的学问精神" class="headerlink" title="严谨的学问精神"></a>严谨的学问精神</h2><p>竺可桢在学问上的严谨和我有着很多相似之处，对于自己的成果总是反复的修改，力图达到自身最满意的程度，这里我将之称为“效果”思想。我常常也是力图将事情做到最好，对于自己写的文章字字斟酌，做的事情反复思量，以前我常常怀疑自己的做法是不是正确的，现在发现和老校长不谋而合，内心感到很宽慰。<br>很多时候为了效率，公司希望你用20%的时间将事情做到80%即可，这种思想很多时候在商业世界是投入产出比高的选择，这里我将之称为“效率”思想。“效率”思想过度的泛滥会导致产出的作品质量低下，公司赚到了钱，却伤害了消费者。<br>“效果”和“效率”思想都是有可取之处的，并且需要并行，在不同的场景，要用不同的思想去解决问题。在一些无关紧要的事情上，应尽可能投入少的时间获得大的收益，一昧投入只会越陷越深；在一些重大的事情上，必须投入120%的努力，精益求精。在特定的场景下如何选择这两种思想，事实上是一个广泛性的问题，我们所有人都在不停地面临这样的选择。能够拥有选择的智慧，是一件幸事。</p>
<h2 id="百折不挠的抗争精神"><a href="#百折不挠的抗争精神" class="headerlink" title="百折不挠的抗争精神"></a>百折不挠的抗争精神</h2><p>8年西迁，4易校址。中途还遭遇了妻子过世这样沉重的打击，但是竺可桢没有被打倒，反而在困境之中将学校越办越好，获得世界瞩目的科研成果，培养了比非困难时期更多的优秀学生。相比抗战年代的苦难，我们今天的一些个人的困难又算的了什么呢，在那种环境下他们可以坚持下去，我们更应该可以。</p>
<h2 id="人生的关键选择"><a href="#人生的关键选择" class="headerlink" title="人生的关键选择"></a>人生的关键选择</h2><p>竺可桢校长提到，“大学教育的目标，决不仅仅是造就多少专家如工程师医生之类，而尤在乎养成公忠坚毅，能担当大任，主持风尚，转移国运的领导人才。”然而想到当初毕业时，有很多人不知道要做什么，有些人想安稳的度过一生，有些人有想法但不知自己具体该如何做，而我其实也在曾这三者之间徘徊。大学时我常常去图书馆读书，有幸能让自己的视野更广阔一点，但在面临人生方向的选择的时候，仍然觉得自己所知道的远远不够，无法找到确切的答案。我想，一方面是自身的阅历太少；一方面每个人的经历与自身情况又大不相同，他人的选择无法复制到自己身上。我们不仅要“知”，还要有“智”，这样才能做出更好的选择。所幸的是，我一直没有放弃追问，在毕业后的五年，遇到了更多的事，逐渐开始形成自己的答案。我给自己制定了短期和长期的规划：</p>
<h3 id="3年的规划"><a href="#3年的规划" class="headerlink" title="3年的规划"></a>3年的规划</h3><p>1.在技术领域继续深耕，达到行业专家或更高水平；<br>2.打造自身的IP，通过个人文章、作品来影响或帮助到一些行业从业者；<br>3.逐步提升商业视野，了解商业运行规律，开始构建自己的商业知识体系与资源网络；</p>
<h3 id="长期的规划"><a href="#长期的规划" class="headerlink" title="长期的规划"></a>长期的规划</h3><p>1.持续阅读，丰富自身的人文知识、人生阅历；<br>2.不断学习一切可以学习的事物，补齐自身的短板，<br>3.了解世界，探索自身能力的边界；<br>4.照顾好家人；<br>5.多运动；<br>6.向他人学习；<br>7.35岁左右拥有一些良性的财富资产；</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/05/python-%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WaterYoungMan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WaterYoungMan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/05/python-%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F/" class="post-title-link" itemprop="url">python-如何解析文件的编码格式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-08-05 07:58:58 / Modified: 08:06:42" itemprop="dateCreated datePublished" datetime="2022-08-05T07:58:58+08:00">2022-08-05</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>python直接打开非utf-8编码格式的文件，并使用readline()读取内容，会出现字节解析失败。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(file, &#x27;r&#x27;) as f:</span><br><span class="line">	str = f.readline()</span><br></pre></td></tr></table></figure>
<p>报错信息如下：</p>
<blockquote>
<p>UnicodeDecodeError: ‘utf-8’ codec can’t decode byte 0xff in position 0: invalid start byte</p>
</blockquote>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>1.python的默认文件解析格式是utf-8，如果被打开的文件是非utf-8编码，那么后续的文本处理就无法顺利执行。<br>2.我们需要在open时指定文件的编码格式，类似于<code>open(filename, encoding=&#39;gbk2312&#39;)</code><br>3.需要有途径能获知文件编码格式。</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>使用chardet库可以自动分析字节流的编码格式，借用chardet可以分析文件的编码格式。</p>
<h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import chardet</span><br><span class="line">def predict_encoding(file_path):</span><br><span class="line">    with open(file_path, &#x27;rb&#x27;) as f:</span><br><span class="line">        d = chardet.detect(f.read())</span><br><span class="line">        print(d)</span><br><span class="line">        file_encoding = d[&#x27;encoding&#x27;]</span><br><span class="line">    return file_encoding</span><br></pre></td></tr></table></figure>
<p>方法一会将文件中所有内容进行编码解析，遇到文件内容较大时，执行时间较长。<br>我们也可以只读取文件的开头一定行数的字节，再解析其编码，如方法二只读取文件的前1000行：</p>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import chardet</span><br><span class="line"># 注意：默认n_lines大小可自行修改</span><br><span class="line">def predict_encoding(file_path, n_lines=1000):</span><br><span class="line">    with open(file_path, &#x27;rb&#x27;) as f:</span><br><span class="line">        rawdata = b&#x27;&#x27;.join([f.readline() for _ in range(n_lines)])</span><br><span class="line">        d = chardet.detect(rawdata)</span><br><span class="line">        print(d)</span><br><span class="line">        file_encoding = d[&#x27;encoding&#x27;]</span><br><span class="line">    return file_encoding</span><br></pre></td></tr></table></figure>
<p>值得注意的是，chardet的预测并不是绝对正确，通常它的返回值会给出一个预测概率（在’confidence’字段）。因为文件本质上是字节流的组合，文件的读入者无法保证创建者在一个文件中只使用一种编码格式，还是多种编码格式。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>在读入文件大小可控，行数小于一千行的时候，使用方法一。</li>
<li>在读入文件大小未知的使用场景，使用方法二，该方法执行时间更可控。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/05/python-%E4%B8%80%E6%96%87%E5%BC%84%E6%87%82pip/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WaterYoungMan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WaterYoungMan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/05/python-%E4%B8%80%E6%96%87%E5%BC%84%E6%87%82pip/" class="post-title-link" itemprop="url">python-一文弄懂pip</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-08-05 07:20:19 / Modified: 08:06:47" itemprop="dateCreated datePublished" datetime="2022-08-05T07:20:19+08:00">2022-08-05</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="pip是什么"><a href="#pip是什么" class="headerlink" title="pip是什么"></a>pip是什么</h2><p>pip是python的一个包管理工具，用于安装、卸载python的库(或称模块)。类似于ubuntu的apt，nodejs的npm。<br>当调用python模块时出现类似于<code>ModuleNotFoundError: No module named &#39;xxx&#39;</code>的错误，就需要用pip来安装相应的python模块了。</p>
<p>在pip安装python模块的时候经常会看到网上里有各种推荐的安装方式，例如：<br><code>pip install，pip3 install，python -m pip install，python2 -m pip install，python3 -m pip install</code><br>那么这些方式各有什么区别，我应该使用哪一种呢？<br>要弄明白这个问题，首先需要弄清楚执行这些指令时发生了什么。</p>
<h2 id="在ternimal下执行指令时发生了什么"><a href="#在ternimal下执行指令时发生了什么" class="headerlink" title="在ternimal下执行指令时发生了什么"></a>在ternimal下执行指令时发生了什么</h2><p>事实上我们在linux的terminal下执行类似<code>cd, ls, git, nodejs，python，pip</code>这些指令的时候，本质上是在调用某个可执行文件，而这些可执行文件是通过linux的环境变量PATH去查找的（其他操作系统同理），所以当我们在安装某些软件时，如果想在ternimal下直接调用就需要去配置环境变量PATH。<br>我们可以通过<code>whereis xxx</code>来查找这些命令指向的位置。<br>执行指令可能直接调用执行文件，也可能间接调用。我将执行指令分为以下几类：</p>
<ul>
<li>指令名就是可执行文件名，如 <code>ls, git</code> （有些是linux系统安装时编译的，有些是后期安装软件时编译的）</li>
<li>指令名是可执行文件名的软链接，执行软链接时再跳转到链接指向的位置，如 <code>noidejs, python</code></li>
<li>指令名是shell内置命令，即shell负责解释这些指令，相应的执行操作由shell解释完再操作，如 <code>cd</code>。</li>
<li>指令名是可执行文件的别名（alias），如oh-my-zsh默认会将<code>git status -s</code>别名为更简短的<code>gst</code>，我们也可以在<del>&#x2F;.bashrc，</del>&#x2F;.zshrc这样的文件中增加自定义别名</li>
</ul>
<h2 id="如何安装pip"><a href="#如何安装pip" class="headerlink" title="如何安装pip"></a>如何安装pip</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">python3的pip安装：</span><br><span class="line">curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py </span><br><span class="line">python3 get-pip.py</span><br><span class="line"></span><br><span class="line">python2的pip安装：</span><br><span class="line">curl https://bootstrap.pypa.io/pip/2.7/get-pip.py -o get-pip.py </span><br><span class="line">python2 get-pip.py</span><br></pre></td></tr></table></figure>
<p>对于默认为python3版本的环境，也可以通过<code>sudo apt install pip</code>来安装</p>
<h2 id="pip执行文件存放在哪"><a href="#pip执行文件存放在哪" class="headerlink" title="pip执行文件存放在哪"></a>pip执行文件存放在哪</h2><p>pip的可执行文件位置：<br><code>/usr/bin/pip</code><br>pip的源代码位置(存放在相应的python版本下面)：<br><code>~/.local/lib/python3.8/site-packages</code></p>
<h2 id="执行pip时发生了什么"><a href="#执行pip时发生了什么" class="headerlink" title="执行pip时发生了什么"></a>执行pip时发生了什么</h2><ol>
<li>通过<code>whereis pip</code>可知执行文件存放在<code>/usr/bin/</code></li>
<li>通过<code>ls -al /usr/bin | grep pip</code>可以看出来<code>/usr/bin/pip</code>不是一个软链接，实际上是一个python文件，只是这个文件没有<code>.py</code>后缀而已，所以执行pip相当于执行test.py这样的python文件</li>
<li>通过查看<code>/usr/bin/pip</code>的内容可知，执行pip时会通过首行的<code>#!/usr/bin/python3</code>来告知内核当未指定执行程序，将默认用<code>/usr/bin/python3</code>来执行。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">╰─ cat /usr/bin/pip</span><br><span class="line">#!/usr/bin/python3</span><br><span class="line"># EASY-INSTALL-ENTRY-SCRIPT: &#x27;pip==20.0.2&#x27;,&#x27;console_scripts&#x27;,&#x27;pip&#x27;</span><br><span class="line">__requires__ = &#x27;pip==20.0.2&#x27;</span><br><span class="line">import re</span><br><span class="line">import sys</span><br><span class="line">from pkg_resources import load_entry_point</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    sys.argv[0] = re.sub(r&#x27;(-script\.pyw?|\.exe)?$&#x27;, &#x27;&#x27;, sys.argv[0])</span><br><span class="line">    sys.exit(</span><br><span class="line">        load_entry_point(&#x27;pip==20.0.2&#x27;, &#x27;console_scripts&#x27;, &#x27;pip&#x27;)()</span><br><span class="line">    )</span><br></pre></td></tr></table></figure></li>
<li>因此在terminal下执行pip的实际流程为：</li>
</ol>
<ul>
<li>通过环境变量PATH找到名为pip的可执行文件所处的文件夹</li>
<li>直接执行<code>pip</code>相当于执行<code>/usr/bin/python3 pip</code>。</li>
</ul>
<h2 id="执行pip3发生了什么"><a href="#执行pip3发生了什么" class="headerlink" title="执行pip3发生了什么"></a>执行pip3发生了什么</h2><p>pip3和pip的原理几乎是一样的，同样的方式我们可以看到pip3的文件内容和pip几乎没有差别：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">╰─ cat /usr/bin/pip3</span><br><span class="line">#!/usr/bin/python3</span><br><span class="line"># EASY-INSTALL-ENTRY-SCRIPT: &#x27;pip==20.0.2&#x27;,&#x27;console_scripts&#x27;,&#x27;pip3&#x27;</span><br><span class="line">__requires__ = &#x27;pip==20.0.2&#x27;</span><br><span class="line">import re</span><br><span class="line">import sys</span><br><span class="line">from pkg_resources import load_entry_point</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    sys.argv[0] = re.sub(r&#x27;(-script\.pyw?|\.exe)?$&#x27;, &#x27;&#x27;, sys.argv[0])</span><br><span class="line">    sys.exit(</span><br><span class="line">        load_entry_point(&#x27;pip==20.0.2&#x27;, &#x27;console_scripts&#x27;, &#x27;pip3&#x27;)()</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<h2 id="执行python-m-pip发生了什么"><a href="#执行python-m-pip发生了什么" class="headerlink" title="执行python -m pip发生了什么"></a>执行python -m pip发生了什么</h2><ol>
<li>通过<code>whereis python</code>可知执行文件存放在&#x2F;usr&#x2F;bin&#x2F;</li>
<li>通过<code>ls -al /usr/bin | grep python</code>可以看出&#x2F;usr&#x2F;bin&#x2F;python是一个软链接，即python -&gt; &#x2F;usr&#x2F;bin&#x2F;python3</li>
<li>因此在terminal下执行python -m pip的实际流程为：</li>
</ol>
<ul>
<li>通过环境变量PATH找到名为python的可执行文件所处的文件</li>
<li>执行<code>python -m pip</code> 相当于<code>/usr/bin/python -m pip</code></li>
</ul>
<ol start="4">
<li><code>python2 -m pip</code>，<code>python3 -m pip</code>和<code>python -m pip</code>的调用原理是一样的，调用python工具执行其下面的一个名为pip的模块(-m代表module)。</li>
</ol>
<h2 id="pip下载的包安装在哪"><a href="#pip下载的包安装在哪" class="headerlink" title="pip下载的包安装在哪"></a>pip下载的包安装在哪</h2><p>pip安装的路径取决于调用pip时使用的python的版本。<br>如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/.local/lib/python2.7/site-packages</span><br><span class="line">~/.local/lib/python3.8/site-packages</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>pip是一个python的子模块，具备公共python库管理的功能。</li>
<li>使用pip安装python模块的过程就是从源仓库地址下载python包（或称模块，库）并存放在本机文件的过程。</li>
<li>不同的pip安装指令实质的差异是安装包存放的地址差异，这取决最终执行这条指令的python版本，本机的每个python版本都自维护了一个包存放地址。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">WaterYoungMan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">WaterYoungMan</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
