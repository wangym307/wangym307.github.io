<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="WaterYoungMan&#39;s Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="WaterYoungMan&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="WaterYoungMan">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>WaterYoungMan's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">WaterYoungMan's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/23/FreeRTOS%E8%BF%9B%E9%98%B6-%E8%8A%AF%E7%89%87%E7%A7%BB%E6%A4%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WaterYoungMan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WaterYoungMan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/23/FreeRTOS%E8%BF%9B%E9%98%B6-%E8%8A%AF%E7%89%87%E7%A7%BB%E6%A4%8D/" class="post-title-link" itemprop="url">FreeRTOS进阶-芯片移植</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-08-23 00:21:41 / Modified: 00:22:57" itemprop="dateCreated datePublished" datetime="2022-08-23T00:21:41+08:00">2022-08-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a target="_blank" rel="noopener" href="https://github.com/FreeRTOS/FreeRTOS">github开源库</a>的<code>FreeRTOS/Demo</code>目录下已经包含了大量常用芯片的移植代码。如果是未移植过的芯片，可以找相似架构的芯片作为参考。<br>所谓移植，大部分工作是在port.c这个文件中实现FreeRTOS内核要求的硬件接口。</p>
<h2 id="移植过程"><a href="#移植过程" class="headerlink" title="移植过程"></a>移植过程</h2><h3 id="增加FreeRTOS内核代码"><a href="#增加FreeRTOS内核代码" class="headerlink" title="增加FreeRTOS内核代码"></a>增加FreeRTOS内核代码</h3><p>将FreeRTOS内核代码加入编译规则（包括.c和.h）。</p>
<h3 id="修改FreeRTOSConfig-h文件"><a href="#修改FreeRTOSConfig-h文件" class="headerlink" title="修改FreeRTOSConfig.h文件"></a>修改FreeRTOSConfig.h文件</h3><p>这个是FreeRTOS的个性化配置文件，可以从网上下载Demo，并根据自己的需求修改。<br>常见配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">配置tick周期</span><br><span class="line">#define configTICK_RATE_HZ			( ( TickType_t ) 1000 )</span><br><span class="line"></span><br><span class="line">配置内核使用的中断优先级</span><br><span class="line">#define configKERNEL_INTERRUPT_PRIORITY                255</span><br></pre></td></tr></table></figure>
<h3 id="编写一些钩子函数"><a href="#编写一些钩子函数" class="headerlink" title="编写一些钩子函数"></a>编写一些钩子函数</h3><p>如果你在FreeRTOSConfig.h中设置了configUSE_TICK_HOOK&#x3D;1，则必须编写voidvApplicationTickHook( void )函数。该函数利用时间片中断，可以很方便的实现一个定时器功能。</p>
<p>如果你在FreeRTOSConfig.h中设置了configCHECK_FOR_STACK_OVERFLOW&#x3D;1或&#x3D;2，则必须编写voidvApplicationStackOverflowHook( xTaskHandle pxTask, signed char *pcTaskName )函数，该函数用于检测堆栈溢出。</p>
<h3 id="挂接中断"><a href="#挂接中断" class="headerlink" title="挂接中断"></a>挂接中断</h3><p>异常中断服务代码位于port.c文件中，FreeRTOS的作者已经为各种架构的CPU写好了这些代码，可以直接拿来用，需要用户做的，仅仅是将这些异常中断入口地址挂接到启动代码中</p>
<h3 id="创建任务并验证"><a href="#创建任务并验证" class="headerlink" title="创建任务并验证"></a>创建任务并验证</h3><p>调用FreeRTOS提供的API函数来创建任务，并开启调度器vTaskStartScheduler。</p>
<p>int main(void)<br>{<br>    init_serial_debug();&#x2F;&#x2F;初始化调试串口</p>
<pre><code>xTaskCreate(vTask,&quot;Task1&quot;,50,NULL,1,NULL);
vTaskStartScheduler();
while(1);
</code></pre>
<p>}</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/22/%E5%9C%A8linux%E4%B8%8B%E8%BF%9B%E8%A1%8Cwifi%E5%97%85%E6%8E%A2%E6%8A%93%E5%8C%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WaterYoungMan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WaterYoungMan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/22/%E5%9C%A8linux%E4%B8%8B%E8%BF%9B%E8%A1%8Cwifi%E5%97%85%E6%8E%A2%E6%8A%93%E5%8C%85/" class="post-title-link" itemprop="url">在linux下进行wifi嗅探抓包</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-08-22 23:48:31 / Modified: 23:48:50" itemprop="dateCreated datePublished" datetime="2022-08-22T23:48:31+08:00">2022-08-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在原生linux系统下（虚拟机不支持），如果内置WiFi网卡及驱动支持monitor(sniffer)模式，则可以用wireshark直接嗅探抓取空中所有802.11帧，无需购买专门的抓包网卡。</p>
<p>确认网卡是否支持monitor模式的方法是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">iw list | grep &#x27;Supported interface modes&#x27; -A 10</span><br><span class="line"></span><br><span class="line">输出为:</span><br><span class="line">	Supported interface modes:</span><br><span class="line">		 * IBSS</span><br><span class="line">		 * managed</span><br><span class="line">		 * AP</span><br><span class="line">		 * AP/VLAN</span><br><span class="line">		 * monitor</span><br><span class="line">		 * P2P-client</span><br><span class="line">		 * P2P-GO</span><br><span class="line">		 * P2P-device</span><br><span class="line">	Band 1:</span><br><span class="line">		Capabilities: 0x19ef</span><br></pre></td></tr></table></figure>
<p>如果输出中包含“monitor”，则代表当前的网卡和驱动都已支持wifi的sniffer模式，可以正常抓wifi包。</p>
<h2 id="安装wireshark"><a href="#安装wireshark" class="headerlink" title="安装wireshark"></a>安装wireshark</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install wireshark</span><br></pre></td></tr></table></figure>
<p>出现Configuring wireshark-common时选择yes。</p>
<p>添加用户组，让wireshark程序拥有更高的权限，以便于内部使用tcpdump这样的内核工具:<br><code>sudo adduser $USER wireshark</code></p>
<h2 id="设置Monitor模式"><a href="#设置Monitor模式" class="headerlink" title="设置Monitor模式"></a>设置Monitor模式</h2><p>1.查看无线网卡号<br>指令为<code>ifconfig</code>或<code>ip addr</code>，这里我的无线网卡名为“wlp3s0”，下面指令中需将“wlp3s0”替换为你的无线网卡号。</p>
<p>2.设置为混杂模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo service network-manager stop</span><br><span class="line">sudo ifconfig wlp3s0 down(sudo ip addr set wlp3s0 down)</span><br><span class="line">sudo iwconfig wlp3s0 mode Monitor</span><br><span class="line">sudo ifconfig wlp3s0 up(sudo ip addr set wlp3s0 up)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3.查看当前信道<br><code>iwlist wlp3s0 channel</code><br>4.设置信道<br><code>sudo iwconfig wlp3s0 channel 1</code></p>
<h2 id="打开wireshark"><a href="#打开wireshark" class="headerlink" title="打开wireshark"></a>打开wireshark</h2><p>正常情况下，如果已经按照上面的说明将当前用户添加到wireshark组中，则可以直接打开wireshark进行抓包。<br>如果打开wireshark后完全无法抓包，可以尝试以超级用户权限打开wireshark。</p>
<h2 id="结束抓包，切回正常模式"><a href="#结束抓包，切回正常模式" class="headerlink" title="结束抓包，切回正常模式"></a>结束抓包，切回正常模式</h2><p>在Monitor(sniffer)模式下，无法正常使用因特网络。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo ifconfig wlp3s0 down(sudo ip addr set wlp3s0 down)</span><br><span class="line">sudo iwconfig wlp3s0 mode Managed</span><br><span class="line">sudo ifconfig wlp3s0 up(sudo ip addr set wlp3s0 up)</span><br><span class="line">sudo service network-manager restart</span><br></pre></td></tr></table></figure>
<p>无线网卡恢复正常使用。</p>
<h3 id="Tips："><a href="#Tips：" class="headerlink" title="Tips："></a>Tips：</h3><ul>
<li>如果经常使用空中抓包，你可以将以上命令保存为脚本，则可以迅速设置Monitor模式，迅速切回正常模式。</li>
<li>在ubuntu20之后的版本，<code>ifconfig</code>指令已经不再默认安装，转而替换为<code>ip addr</code>系列指令。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/22/gdb-vscode%E5%8F%AF%E8%A7%86%E5%8C%96%E8%B0%83%E8%AF%95%E6%97%B6%E5%A2%9E%E5%8A%A0sudo%E6%9D%83%E9%99%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WaterYoungMan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WaterYoungMan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/22/gdb-vscode%E5%8F%AF%E8%A7%86%E5%8C%96%E8%B0%83%E8%AF%95%E6%97%B6%E5%A2%9E%E5%8A%A0sudo%E6%9D%83%E9%99%90/" class="post-title-link" itemprop="url">gdb-vscode可视化调试时增加sudo权限</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-08-22 23:39:22 / Modified: 23:59:45" itemprop="dateCreated datePublished" datetime="2022-08-22T23:39:22+08:00">2022-08-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><p>不管是命令行调试，还是可视化调试，都需确保要调试的文件在编译时已经增加了cflag”-g”，否则无法增加对应调试信息。</p>
<h2 id="命令行gdb调试"><a href="#命令行gdb调试" class="headerlink" title="命令行gdb调试"></a>命令行gdb调试</h2><p>基础指令：<code>gdb + 可执行文件</code><br>输入<code>r</code>开始运行<br>具体命令行可参阅：<a target="_blank" rel="noopener" href="https://www.modb.pro/db/232755">gdb命令行</a></p>
<h2 id="vscode可视化gdb调试"><a href="#vscode可视化gdb调试" class="headerlink" title="vscode可视化gdb调试"></a>vscode可视化gdb调试</h2><ul>
<li>在工作目录下为调试项目增加”launch.json”</li>
<li>使用vscode左侧的”Run and Debug”工具进行可视化调试，可以轻松增加断点，单步调试，查看变量值等</li>
</ul>
<h3 id="vscode调用的gdb没有sudo权限问题"><a href="#vscode调用的gdb没有sudo权限问题" class="headerlink" title="vscode调用的gdb没有sudo权限问题"></a>vscode调用的gdb没有sudo权限问题</h3><p>gdb运行代码的时候出现<code>Operation not permitted</code>，需要为gdb增加sudo权限，解决方法是新建一个执行文件来间接以sudo方式调用gdb，然后指定vscode将这个执行文件作为gdb工具使用；<br>这么转换的原因是vscode的gdb工具是默认以非sudo方式运行的。</p>
<ol>
<li>工程根目录创建一个名为gdb_sudo的可执行脚本，并赋予执行权限。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;sudo /usr/bin/gdb &quot;$@&quot;&#x27;&gt;gdb_sudo</span><br><span class="line">sudo chmod 777 gdb_sudo</span><br></pre></td></tr></table></figure></li>
<li>增加.vscode文件夹下的launch.json或改动<br>“miDebuggerPath”: “${workspaceRoot}&#x2F;gdb_sudo”</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // Use IntelliSense to learn about possible attributes.</span><br><span class="line">    // Hover to view descriptions of existing attributes.</span><br><span class="line">    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;(gdb) xxx_demo_quickstart&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;cppdbg&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/path/to/bin&quot;,</span><br><span class="line">            &quot;args&quot;: [&quot;&quot;],</span><br><span class="line">            &quot;stopAtEntry&quot;: false,</span><br><span class="line">            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,</span><br><span class="line">            &quot;environment&quot;: [],</span><br><span class="line">            &quot;externalConsole&quot;: false,</span><br><span class="line">            &quot;MIMode&quot;: &quot;gdb&quot;,</span><br><span class="line">            &quot;setupCommands&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,</span><br><span class="line">                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,</span><br><span class="line">                    &quot;ignoreFailures&quot;: true</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            // &quot;miDebuggerPath&quot;: &quot;/usr/bin/gdb&quot;,</span><br><span class="line">            &quot;miDebuggerPath&quot;: &quot;$&#123;workspaceRoot&#125;/gdb_sudo&quot;,</span><br><span class="line">            &quot;postDebugTask&quot;: &quot;Terminate All Tasks&quot;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>更改&#x2F;etc&#x2F;sudoers，增加一行，user_name为自己账号名。<br>user_name ALL&#x3D;(ALL) NOPASSWD:&#x2F;usr&#x2F;bin&#x2F;gdb</li>
</ol>
<h3 id="无法增加断点问题"><a href="#无法增加断点问题" class="headerlink" title="无法增加断点问题"></a>无法增加断点问题</h3><p>如果gdb启动执行文件的时候打印<code>no debugging symbols found</code>，且无法增加断点，可能是编译可执行文件的时候没有增加cflag “-g”</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/22/linux-%E6%9D%83%E9%99%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WaterYoungMan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WaterYoungMan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/22/linux-%E6%9D%83%E9%99%90/" class="post-title-link" itemprop="url">linux-权限</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-08-22 23:34:57 / Modified: 23:40:07" itemprop="dateCreated datePublished" datetime="2022-08-22T23:34:57+08:00">2022-08-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>权限与用户、组的关系是密不可分的。<br>Linux系统中文件的ugo权限是Linux进行权限管理的基本方式，本文将介绍ugo权限的基本概念。</p>
<h2 id="权限的概念"><a href="#权限的概念" class="headerlink" title="权限的概念"></a>权限的概念</h2><h3 id="文件的所有者和组"><a href="#文件的所有者和组" class="headerlink" title="文件的所有者和组"></a>文件的所有者和组</h3><p>Linux 文件的ugo权限把对文件的访问者划分为三个类别：文件的所有者、组和其他人。所谓的 ugo 就是指 user(也称为 owner)、group(所在组)和other(其他组)三个单词的首字母组合。</p>
<p>通过<code>ls -al</code>指令可以查看ugo权限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">╰─○ ls -al /usr/bin/wireshark </span><br><span class="line">-rwxr-xr-x 1 root root 8786544 4月  20  2020 /usr/bin/wireshark</span><br></pre></td></tr></table></figure>

<h3 id="文件的所有者"><a href="#文件的所有者" class="headerlink" title="文件的所有者"></a>文件的所有者</h3><p>文件的所有者一般是创建该文件的用户，对该文件具有完全的权限。在一台允许多个用户访问的Linux主机上，可以通过文件的所有者来区分一个文件属于某个用户。当然，一个用户也无权查看或更改其它用户的文件。<br>上面第一个root代表文件所有者为root。</p>
<h3 id="文件所属的组"><a href="#文件所属的组" class="headerlink" title="文件所属的组"></a>文件所属的组</h3><p>假如有几个用户合作开发同一个项目，如果每个用户只能查看和修改自己创建的文件就太不方便了，也就谈不上什么合作了。所以需要一个机制允许一个用户查看和修改其它用户的文件，此时就用到组的概念的。我们可以创建一个组，然后把需要合作的用户都添加都这个组中。在设置文件的访问权限时，允许这个组中的用户对该文件进行读取和修改。<br>上面第二个root代表文件所属的组为root。</p>
<h3 id="其他人"><a href="#其他人" class="headerlink" title="其他人"></a>其他人</h3><p>如果我想把一个文件共享给系统中的所有用户该怎么办？通过组的方式显然是不合适的，因为需要把系统中的所有用户都添加到一个组中。并且系统中添加了新用户该怎么办，每添加一个新用户就把他添加到这个组中吗？这个问题可以通过其他人的概念解决。在设置文件的访问权限时，允许其他人户对该文件进行读取和修改。</p>
<h2 id="操作权限的指令"><a href="#操作权限的指令" class="headerlink" title="操作权限的指令"></a>操作权限的指令</h2><p>u：user，所有者<br>g：group，所在组<br>o：other，其他组<br>a：all，以上所有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chmod u=rwx g=r o=r 文件名：</span><br><span class="line">表示修改文件的所有者的权限是rwx，所在组r，其他组r，u表示所有者，g表示所在组，o表示其他组。</span><br><span class="line">chmod u+x o-x 文件名：表示所有者加上一个x权限，其他组减去一个x权限。</span><br><span class="line">chmod a=rwx 文件名 ：表示给文件所有者、所在组、其他组都设置rwx权限，a表示所有。</span><br><span class="line">chmod a+r 文件名：表示给文件所有者、所在组、其他组都加上r权限。</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://p3terx.com/archives/add-normal-users-with-adduser-and-useradd.html">https://p3terx.com/archives/add-normal-users-with-adduser-and-useradd.html</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/22/linux-%E7%94%A8%E6%88%B7%E4%B8%8E%E7%BB%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WaterYoungMan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WaterYoungMan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/22/linux-%E7%94%A8%E6%88%B7%E4%B8%8E%E7%BB%84/" class="post-title-link" itemprop="url">linux-用户与组</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-08-22 23:34:21 / Modified: 23:34:48" itemprop="dateCreated datePublished" datetime="2022-08-22T23:34:21+08:00">2022-08-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在 Linux 操作系统中，有时候需要用指令来为某些应用程序增加权限。<br>比如为虚拟机增加usb使用权限，需要增加一个名为usbfs的用户组，并将当前用户添加到usbfs组中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd usbfs</span><br><span class="line">sudo adduser $USER usbfs</span><br><span class="line">cat /etc/group |grep usbfs</span><br></pre></td></tr></table></figure>
<p>那么“为什么增加用户组就可以解决这些权限问题?”，首先需要了解用户和组的概念。<br>“用户-组-权限”三者的关系是密不可分的。</p>
<h2 id="用户与组的概念"><a href="#用户与组的概念" class="headerlink" title="用户与组的概念"></a>用户与组的概念</h2><h3 id="理解linux多用户，多任务的特性"><a href="#理解linux多用户，多任务的特性" class="headerlink" title="理解linux多用户，多任务的特性"></a>理解linux多用户，多任务的特性</h3><p>Linux是一个真实的、完整的多用户多任务操作系统，多用户多任务就是可以在系统上建立多个用户，而多个用户可以在同一时间内登录同一个系统执行各自不同的任务，而互不影响，例如某台linux服务器上有4个用户，分别是root、www、ftp和mysql，在同一时间内，root用户可能在查看系统日志，管理维护系统，www用户可能在修改自己的网页程序，ftp用户可能在上传软件到服务器，mysql用户可能在执行自己的SQL查询，每个用户互不干扰，有条不紊的进行着自己的工作，而每个用户之间不能越权访问，比如www用户不能执行mysql用户的SQL查询操作，ftp用户也不能修改www用户的网页程序，因此可知，不同用户具有不同的权限，每个用户是在权限允许的范围内完成不同的任务，linux正是通过这种权限的划分与管理，实现了多用户多任务的运行机制。</p>
<h3 id="linux下用户的角色分类"><a href="#linux下用户的角色分类" class="headerlink" title="linux下用户的角色分类"></a>linux下用户的角色分类</h3><p> 在linux下用户是根据角色定义的，具体分为三种角色：</p>
<ul>
<li>超级用户：拥有对系统的最高管理权限，默认是root用户。</li>
<li>普通用户：只能对自己目录下的文件进行访问和修改，具有登录系统的权限，例如上面提到的www用户、ftp用户等。</li>
<li>虚拟用户：也叫“伪”用户，这类用户最大的特点是不能登录系统，它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。例如系统默认的bin、adm、nobody用户等，一般运行的web服务，默认就是使用的nobody用户，但是nobody用户是不能登录系统的。</li>
</ul>
<h3 id="用户和组的概念"><a href="#用户和组的概念" class="headerlink" title="用户和组的概念"></a>用户和组的概念</h3><p>我们知道，Linux是一个多用户多任务的分时操作系统，如果要使用系统资源，就必须向系统管理员申请一个账户，然后通过这个账户进入系统。这个账户和用户是一个概念，通过建立不同属性的用户，一方面，可以合理的利用和控制系统资源，另一方面也可以帮助用户组织文件，提供对用户文件的安全性保护。<br>每个用户都用一个唯一的用户名和用户口令，在登录系统时，只有正确输入了用户名和密码，才能进入系统和自己的主目录。<br>用户组是具有相同特征用户的逻辑集合，有时我们需要让多个用户具有相同的权限，比如查看、修改某一个文件的权限，一种方法是分别对多个用户进行文件访问授权，如果有10个用户的话，就需要授权10次，显然这种方法不太合理；另一种方法是建立一个组，让这个组具有查看、修改此文件的权限，然后将所有需要访问此文件的用户放入这个组中，那么所有用户就具有了和组一样的权限。这就是用户组，将用户分组是Linux 系统中对用户进行管理及控制访问权限的一种手段，通过定义用户组，在很大程度上简化了管理工作。</p>
<h3 id="用户和组的关系"><a href="#用户和组的关系" class="headerlink" title="用户和组的关系"></a>用户和组的关系</h3><p>用户和用户组的对应关系有：一对一、一对多、多对一和多对多；</p>
<ul>
<li>一对一：即一个用户可以存在一个组中，也可以是组中的唯一成员。</li>
<li>一对多：即一个用户可以存在多个用户组中。那么此用户具有多个组的共同权限。</li>
<li>多对一：多个用户可以存在一个组中，这些用户具有和组相同的权限。</li>
<li>多对多：多个用户可以存在多个组中。其实就是上面三个对应关系的扩展。</li>
</ul>
<h2 id="操作指令"><a href="#操作指令" class="headerlink" title="操作指令"></a>操作指令</h2><h3 id="增删用户"><a href="#增删用户" class="headerlink" title="增删用户"></a>增删用户</h3><p>adduser deluser</p>
<h3 id="用户操作"><a href="#用户操作" class="headerlink" title="用户操作"></a>用户操作</h3><p>useradd userdel usermod</p>
<h3 id="组操作"><a href="#组操作" class="headerlink" title="组操作"></a>组操作</h3><p>groupadd groupdel groupmod</p>
<h3 id="useradd-与adduser的区别"><a href="#useradd-与adduser的区别" class="headerlink" title="useradd 与adduser的区别"></a>useradd 与adduser的区别</h3><ul>
<li>adduser是一个 perl 脚本，通过交互式菜单设定一些用户参数。在输入adduser 用户名后，会自动创建用户主目录（并复制&#x2F;etc&#x2F;skel目录下的文件）、指定系统 shell，提示输入用户密码，很简单的就添加了一个标准的普通用户。</li>
<li>useradd是一个指令，如果不使用任何选项，创建的用户将无密码、无主目录、没有指定 shell。如果你需要正常使用这个账户，就还需要设置密码、创建家目录等额外操作。</li>
</ul>
<p>以下是执行<code>man useradd</code>获得的一段作者对于useradd的描述，可以看出useradd相比adduser是更偏底层的指令：</p>
<blockquote>
<p>DESCRIPTION<br>useradd is a low level utility for adding users. On Debian,<br>administrators should usually use adduser(8) instead.</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/401618">https://developer.aliyun.com/article/401618</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/22/esp32c3-%E6%89%A7%E8%A1%8Cexport-sh%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WaterYoungMan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WaterYoungMan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/22/esp32c3-%E6%89%A7%E8%A1%8Cexport-sh%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">esp32c3-执行export.sh失败问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-08-22 02:02:51 / Modified: 02:03:24" itemprop="dateCreated datePublished" datetime="2022-08-22T02:02:51+08:00">2022-08-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>export.sh是乐鑫开发框架esp-idf的一个编译环境自动导入脚本，每次编译之前都需要执行。<br>一次在ubuntu虚拟机中执行esp-idf的export.sh时出现了卡住的情况，异常日志如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Detecting the Python interpreter</span><br><span class="line">Checking &quot;python3&quot; ...</span><br><span class="line">Python 3.8.10</span><br><span class="line">&quot;python3&quot; has been detected</span><br><span class="line">Checking Python compatibility</span><br><span class="line">Checking other ESP-IDF version.</span><br><span class="line">Adding ESP-IDF tools to PATH...</span><br><span class="line">Using a supported version of tool cmake found in PATH: 3.16.3.</span><br><span class="line">However the recommended version is 3.23.1.</span><br><span class="line">Using Python interpreter in /home/wang/.espressif/python_env/idf5.0_py3.8_env/bin/python</span><br><span class="line">Checking if Python packages are up to date...</span><br><span class="line">Downloading https://dl.espressif.com/dl/esp-idf/</span><br><span class="line">Destination: /home/wang/.espressif/espidf.constraints.v5.0.txt.tmp</span><br></pre></td></tr></table></figure>
<p>从日志可以看出，下载配置文件espidf.constraints.v5.0.txt出现异常。</p>
<h2 id="解决方法一"><a href="#解决方法一" class="headerlink" title="解决方法一"></a>解决方法一</h2><p>通过在esp-idf源码中搜索错误日志定位到idf_tools.py的一个函数，读了代码发现下载这个配置文件前会检查espidf.constraints.v5.0.txt的更新日期与当前日期之差，如果超过一天才会下载更新。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def get_constraints(idf_version):  # type: (str) -&gt; str</span><br><span class="line">    constraint_file = &#x27;espidf.constraints.v&#123;&#125;.txt&#x27;.format(idf_version)</span><br><span class="line">    constraint_path = os.path.join(global_idf_tools_path or &#x27;&#x27;, constraint_file)</span><br><span class="line">    constraint_url = &#x27;/&#x27;.join([IDF_DL_URL, constraint_file])</span><br><span class="line">    temp_path = constraint_path + &#x27;.tmp&#x27;</span><br><span class="line"></span><br><span class="line">    mkdir_p(os.path.dirname(temp_path))</span><br><span class="line">    try:</span><br><span class="line">        age = datetime.date.today() - datetime.date.fromtimestamp(os.path.getmtime(constraint_path))</span><br><span class="line">        if age &lt; datetime.timedelta(days=1):</span><br><span class="line">            info(f&#x27;Skipping the download of &#123;constraint_path&#125; because it was downloaded recently. If you believe &#x27;</span><br><span class="line">                 f&#x27;that this is causing you trouble then remove it manually and re-run your install script.&#x27;)</span><br><span class="line">            return constraint_path</span><br><span class="line">    except OSError:</span><br><span class="line">        # doesn&#x27;t exist or inaccessible</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure>
<p>解决方法有两种：</p>
<ol>
<li><p>如果该文件已经存在，则更新文件时间即可<br>进入到该目录下手动更新该文件的时间。<br>cd ~&#x2F;.espressif<br>touch espidf.constraints.v5.0.txt</p>
</li>
<li><p>如果该文件不存在，手动下载文件即可<br>手动下载<a target="_blank" rel="noopener" href="https://dl.espressif.com/dl/esp-idf/espidf.constraints.v5.0.txt">https://dl.espressif.com/dl/esp-idf/espidf.constraints.v5.0.txt</a><br>再拷贝到&#x2F;home&#x2F;wang&#x2F;.espressif&#x2F;espidf.constraints.v5.0.txt</p>
</li>
</ol>
<p>以上两种改动都会导致再次执行export.sh时认为espidf.constraints.v5.0.txt刚刚更新过，不会再执行下载动作，也就避免了下载卡顿问题。但这两种做法都只是通过避免下载来绕过问题，并没有真正解决下载失败问题。</p>
<h2 id="解决方法二"><a href="#解决方法二" class="headerlink" title="解决方法二"></a>解决方法二</h2><p>根本问题在于在terminal通过脚本到<a target="_blank" rel="noopener" href="https://dl.espressif.com下载文件失败./">https://dl.espressif.com下载文件失败。</a><br>于是我在terminal中尝试ping了一下dl.espressif.com，发现也是失败，但是用chrome浏览器打开这个地址却是正常的，这说明在浏览器和terminal中访问一个域名，实际经过的路径是不一样的。<br>于是在terminal中ping了一下其他域名，发现有的能通有的不能通：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ping www.qq.com失败</span><br><span class="line">ping qq.com正常</span><br><span class="line">ping www.baidu.com正常</span><br><span class="line">ping baidu.com正常</span><br></pre></td></tr></table></figure>
<p>因此我怀疑在虚拟机自身的DNS服务出现了问题。<br>网上建议修改&#x2F;etc&#x2F;resolv.conf，增加DNS服务器地址。<br>打开后发现文件作者建议我们不要直接修改conf文件，而是需要通过resolvectl去操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># This file is managed by man:systemd-resolved(8). Do not edit.</span><br><span class="line">#</span><br><span class="line"># This is a dynamic resolv.conf file for connecting local clients to the</span><br><span class="line"># internal DNS stub resolver of systemd-resolved. This file lists all</span><br><span class="line"># configured search domains.</span><br><span class="line">#</span><br><span class="line"># Run &quot;resolvectl status&quot; to see details about the uplink DNS servers</span><br><span class="line"># currently in use.</span><br><span class="line">#</span><br><span class="line"># Third party programs must not access this file directly, but only through the</span><br><span class="line"># symlink at /etc/resolv.conf. To manage man:resolv.conf(5) in a different way,</span><br><span class="line"># replace this symlink by a static file or a different symlink.</span><br><span class="line">#</span><br><span class="line"># See man:systemd-resolved.service(8) for details about the supported modes of</span><br><span class="line"># operation for /etc/resolv.conf.</span><br><span class="line"></span><br><span class="line">nameserver 127.0.0.53</span><br><span class="line">options edns0 trust-ad</span><br><span class="line">search localdomain</span><br></pre></td></tr></table></figure>
<p>联想到最近有将虚拟机的NAT模式改为桥接模式，而之前NAT模式下执行export.sh是正常的。</p>
<ul>
<li>桥接模式相当于从主机虚拟一个网卡出来给虚拟机使用，虚拟机和主机处于同一局域网。</li>
<li>NAT模式是虚拟机处于主机的子网当中，相当于虚拟机把主机当做一个路由器，虚拟机位于LAN口。</li>
</ul>
<p>于是我将虚拟机从NAT模式改回了桥接模式，结果之前ping不通的<a target="_blank" rel="noopener" href="http://www.qq.com和dl.espressif.com都能ping通了,export.sh也能正常的执行完毕./">www.qq.com和dl.espressif.com都能ping通了，export.sh也能正常的执行完毕。</a><br>猜想NAT模式下，虚拟机的ternimal中执行DNS时有先经过主机的DNS服务；而桥接模式下虚拟机DNS不经过主机，而是直接经过主机上级路由器。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>当前export.sh卡顿的根源在于该脚本从dl.espressif.com下载文件失败。<br>可以通过手动下载文件来绕过问题，也可以通过修复DNS问题来根本性解决问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/22/ARM%E6%8C%87%E4%BB%A4-LDR/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WaterYoungMan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WaterYoungMan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/22/ARM%E6%8C%87%E4%BB%A4-LDR/" class="post-title-link" itemprop="url">ARM指令-LDR</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-08-22 01:45:32 / Modified: 01:49:40" itemprop="dateCreated datePublished" datetime="2022-08-22T01:45:32+08:00">2022-08-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>LDR是ARM的指令，也是伪指令</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>LDR{条件} 目的寄存器 &lt;存储器地址&gt;<br>作用：将存储器地址所指地址处连续的4个字节（1个字）的数据传送到目的寄存器中。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LDR R0，[R1] ；将存储器地址为R1的字数据读入寄存器R0。</span><br><span class="line">LDR R0，[R1，R2] ；将存储器地址为R1+R2的字数据读入寄存器R0。</span><br><span class="line">LDR R0，[R1，#8] ；将存储器地址为R1+8的字数据读入寄存器R0。</span><br><span class="line">LDR R0，[R1]，R2 ；将存储器地址为R1的字数据读入寄存器R0，然后R1=R1+8。</span><br><span class="line">LDR R0，[R1]，#8 ；将存储器地址为R1的字数据读入寄存器R0，并将R1+8的值存入R1。</span><br><span class="line">LDR R0，[R1，R2]! ；将存储器地址为R1+R2的字数据读入寄存器R0，并将R1+R2的值存入R1。</span><br><span class="line">LDR R0，[R1，LSL #3] ；将存储器地址为R18的字数据读入寄存器R0。</span><br><span class="line">LDR R0，[R1，R2，LSL #2] ；将存储器地址为R1+R24的字数据读入寄存器R0。</span><br><span class="line">LDR R0，[R1，，R2，LSL #2]！ ；将存储器地址为R1+R24的字数据读入寄存器R0，并将R1+R24的值存入R1。</span><br><span class="line">LDR R0，[R1]，R2，LSL #2 ；将存储器地址为R1的字数据读入寄存器R0，并将R1+R2*4的值存入R1。</span><br><span class="line">LDR R0，Label ；Label为程序标号，Label必须是当前指令的-4~4KB范围内。</span><br></pre></td></tr></table></figure>
<p>要注意的是:<br>LDR Rd，[Rn]，#0x04 ；这里Rd不允许是R15。</p>
<h2 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h2><h3 id="LDRB和LDRH"><a href="#LDRB和LDRH" class="headerlink" title="LDRB和LDRH"></a>LDRB和LDRH</h3><p>另外LDRB 的指令格式与LDR相似，只不过它是将存储器地址中的8位（1个字节）读到目的寄存器中。<br>LDRH的指令格式也与LDR相似，它是将内存中的16位（半字）读到目的寄存器中。</p>
<h3 id="LDR-R0，-x3D-0xff"><a href="#LDR-R0，-x3D-0xff" class="headerlink" title="LDR R0，&#x3D;0xff"></a>LDR R0，&#x3D;0xff</h3><p>这里的LDR不是arm指令，而是伪指令。这个时候与MOVE很相似，只不过MOV指令后的立即数是有限制的。这个立即数必须是0X00-0XFF范围内的数经过偶数次右移得到的数，所以MOV用起来比较麻烦，因为有些数不那么容易看出来是否合法。</p>
<h3 id="LDR-R，label-和-LDR-R，-x3D-label的区别"><a href="#LDR-R，label-和-LDR-R，-x3D-label的区别" class="headerlink" title="LDR R，label 和 LDR R，&#x3D;label的区别"></a>LDR R，label 和 LDR R，&#x3D;label的区别</h3><p>当用 LDR r， &#x3D;imd &#x2F;&#x2F; r 为寄存器， imd为立即数<br>LDR 是一条伪指令。编译器会根据 立即数的大小，决定用 ldr 指令或者是mov或mvn指令。<br>当imd能用mov或者mvn操作时，就将它翻译成一条mov或mvn指令。当imd大于mov或mvn能够操作的数时，编译器会将imd存在一个内存单元中，然后再用一条ldr指令加载这个内存单元的的值到寄存器中。<br>LDR r， label 和 LDR r， &#x3D;label的区别：<br>LDR r， &#x3D;label 会把label表示的值加载到寄存器中，而LDR r， label会把label当做地址，把label指向的地址中的值加载到寄存器中。<br>譬如 label的值是 0x8000， LDR r， &#x3D;label会将 0x8000加载到寄存器中，而LDR r， label则会将内存0x8000处的值加载到寄存器中。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/66d801c85ee9">https://www.jianshu.com/p/66d801c85ee9</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/22/ARM%E6%8C%87%E4%BB%A4-cpsid%E5%92%8Ccpsie/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WaterYoungMan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WaterYoungMan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/22/ARM%E6%8C%87%E4%BB%A4-cpsid%E5%92%8Ccpsie/" class="post-title-link" itemprop="url">ARM指令-cpsid和cpsie</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-08-22 01:44:35 / Modified: 23:40:20" itemprop="dateCreated datePublished" datetime="2022-08-22T01:44:35+08:00">2022-08-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>cpsid和cpsie不是通用汇编指令，而是arm指令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cps = Change Processor State`</span><br><span class="line">id = irq_disable</span><br><span class="line">ie = irq_enable</span><br></pre></td></tr></table></figure>
<h2 id="中断开关"><a href="#中断开关" class="headerlink" title="中断开关"></a>中断开关</h2><p>i &#x3D; interrupt</p>
<h3 id="cpsid-i"><a href="#cpsid-i" class="headerlink" title="cpsid i"></a>cpsid i</h3><p>禁用中断</p>
<h3 id="cpsie-i"><a href="#cpsie-i" class="headerlink" title="cpsie i"></a>cpsie i</h3><p>使能中断</p>
<h2 id="异常开关"><a href="#异常开关" class="headerlink" title="异常开关"></a>异常开关</h2><p>f &#x3D; faultmask</p>
<h3 id="cpsid-f"><a href="#cpsid-f" class="headerlink" title="cpsid f"></a>cpsid f</h3><p>禁用异常</p>
<h3 id="cpsie-f"><a href="#cpsie-f" class="headerlink" title="cpsie f"></a>cpsie f</h3><p>使能异常</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/22/FreeRTOS%E6%BA%90%E7%A0%81%E7%B2%BE%E8%AF%BB-xTaskIncrementTick/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WaterYoungMan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WaterYoungMan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/22/FreeRTOS%E6%BA%90%E7%A0%81%E7%B2%BE%E8%AF%BB-xTaskIncrementTick/" class="post-title-link" itemprop="url">FreeRTOS源码精读-xTaskIncrementTick</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-08-22 01:01:17 / Modified: 01:02:53" itemprop="dateCreated datePublished" datetime="2022-08-22T01:01:17+08:00">2022-08-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>将FreeRTOS的系统tick时间xTickCount+1，并检查是否有时间溢出事件；<br>返回值是<code>是否需要切换任务</code>。</p>
<h2 id="调用者"><a href="#调用者" class="headerlink" title="调用者"></a>调用者</h2><p>xTaskIncrementTick有2处被调用：</p>
<ol>
<li>在系统tick中断函数中调用，由xPortSysTickHandler的返回值告知是否需要进行任务切换，如果是通过修改寄存器portNVIC_INT_CTRL_REG来触发PendSV中断，进而切换任务。<br>以ARM_CM3为例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void xPortSysTickHandler( void )</span><br><span class="line">&#123;</span><br><span class="line">    /* The SysTick runs at the lowest interrupt priority, so when this interrupt</span><br><span class="line">     * executes all interrupts must be unmasked.  There is therefore no need to</span><br><span class="line">     * save and then restore the interrupt mask value as its value is already</span><br><span class="line">     * known. */</span><br><span class="line">    portDISABLE_INTERRUPTS();</span><br><span class="line">    &#123;</span><br><span class="line">        /* Increment the RTOS tick. */</span><br><span class="line">        if( xTaskIncrementTick() != pdFALSE )</span><br><span class="line">        &#123;</span><br><span class="line">            /* A context switch is required.  Context switching is performed in</span><br><span class="line">             * the PendSV interrupt.  Pend the PendSV interrupt. */</span><br><span class="line">            portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    portENABLE_INTERRUPTS();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在xTaskResumeAll中调用，有时调度器会被挂起，此时xTickCount并没有及时+1，而是暂存在xPendedCounts中。等到调度器恢复的时候，再补执行。</li>
</ol>
<h2 id="函数源码"><a href="#函数源码" class="headerlink" title="函数源码"></a>函数源码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t xTaskIncrementTick( void )</span><br><span class="line">&#123;</span><br><span class="line">    TCB_t * pxTCB;</span><br><span class="line">    TickType_t xItemValue;</span><br><span class="line">    BaseType_t xSwitchRequired = pdFALSE;</span><br><span class="line"></span><br><span class="line">    /* Called by the portable layer each time a tick interrupt occurs.</span><br><span class="line">     * Increments the tick then checks to see if the new tick value will cause any</span><br><span class="line">     * tasks to be unblocked. */</span><br><span class="line">    traceTASK_INCREMENT_TICK( xTickCount );</span><br><span class="line"></span><br><span class="line">    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )</span><br><span class="line">    &#123;</span><br><span class="line">        /* Minor optimisation.  The tick count cannot change in this</span><br><span class="line">         * block. */</span><br><span class="line">        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;</span><br><span class="line"></span><br><span class="line">        /* Increment the RTOS tick, switching the delayed and overflowed</span><br><span class="line">         * delayed lists if it wraps to 0. */</span><br><span class="line">        xTickCount = xConstTickCount;</span><br><span class="line"></span><br><span class="line">        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 &#x27;if&#x27; does not always evaluate to false as it is looking for an overflow. */</span><br><span class="line">        &#123;</span><br><span class="line">            taskSWITCH_DELAYED_LISTS();</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* See if this tick has made a timeout expire.  Tasks are stored in</span><br><span class="line">         * the  queue in the order of their wake time - meaning once one task</span><br><span class="line">         * has been found whose block time has not expired there is no need to</span><br><span class="line">         * look any further down the list. */</span><br><span class="line">        if( xConstTickCount &gt;= xNextTaskUnblockTime )</span><br><span class="line">        &#123;</span><br><span class="line">            for( ; ; )</span><br><span class="line">            &#123;</span><br><span class="line">                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )</span><br><span class="line">                &#123;</span><br><span class="line">                    /* The delayed list is empty.  Set xNextTaskUnblockTime</span><br><span class="line">                     * to the maximum possible value so it is extremely</span><br><span class="line">                     * unlikely that the</span><br><span class="line">                     * if( xTickCount &gt;= xNextTaskUnblockTime ) test will pass</span><br><span class="line">                     * next time through. */</span><br><span class="line">                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    /* The delayed list is not empty, get the value of the</span><br><span class="line">                     * item at the head of the delayed list.  This is the time</span><br><span class="line">                     * at which the task at the head of the delayed list must</span><br><span class="line">                     * be removed from the Blocked state. */</span><br><span class="line">                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */</span><br><span class="line">                    xItemValue = listGET_LIST_ITEM_VALUE( &amp;( pxTCB-&gt;xStateListItem ) );</span><br><span class="line"></span><br><span class="line">                    if( xConstTickCount &lt; xItemValue )</span><br><span class="line">                    &#123;</span><br><span class="line">                        /* It is not time to unblock this item yet, but the</span><br><span class="line">                         * item value is the time at which the task at the head</span><br><span class="line">                         * of the blocked list must be removed from the Blocked</span><br><span class="line">                         * state -  so record the item value in</span><br><span class="line">                         * xNextTaskUnblockTime. */</span><br><span class="line">                        xNextTaskUnblockTime = xItemValue;</span><br><span class="line">                        break; /*lint !e9011 Code structure here is deemed easier to understand with multiple breaks. */</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    /* It is time to remove the item from the Blocked state. */</span><br><span class="line">                    listREMOVE_ITEM( &amp;( pxTCB-&gt;xStateListItem ) );</span><br><span class="line"></span><br><span class="line">                    /* Is the task waiting on an event also?  If so remove</span><br><span class="line">                     * it from the event list. */</span><br><span class="line">                    if( listLIST_ITEM_CONTAINER( &amp;( pxTCB-&gt;xEventListItem ) ) != NULL )</span><br><span class="line">                    &#123;</span><br><span class="line">                        listREMOVE_ITEM( &amp;( pxTCB-&gt;xEventListItem ) );</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    /* Place the unblocked task into the appropriate ready</span><br><span class="line">                     * list. */</span><br><span class="line">                    prvAddTaskToReadyList( pxTCB );</span><br><span class="line"></span><br><span class="line">                    /* A task being unblocked cannot cause an immediate</span><br><span class="line">                     * context switch if preemption is turned off. */</span><br><span class="line">                    #if ( configUSE_PREEMPTION == 1 )</span><br><span class="line">                    &#123;</span><br><span class="line">                        /* Preemption is on, but a context switch should</span><br><span class="line">                         * only be performed if the unblocked task has a</span><br><span class="line">                         * priority that is equal to or higher than the</span><br><span class="line">                         * currently executing task. */</span><br><span class="line">                        if( pxTCB-&gt;uxPriority &gt;= pxCurrentTCB-&gt;uxPriority )</span><br><span class="line">                        &#123;</span><br><span class="line">                            xSwitchRequired = pdTRUE;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else</span><br><span class="line">                        &#123;</span><br><span class="line">                            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    #endif /* configUSE_PREEMPTION */</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* Tasks of equal priority to the currently running task will share</span><br><span class="line">         * processing time (time slice) if preemption is on, and the application</span><br><span class="line">         * writer has not explicitly turned time slicing off. */</span><br><span class="line">        #if ( ( configUSE_PREEMPTION == 1 ) &amp;&amp; ( configUSE_TIME_SLICING == 1 ) )</span><br><span class="line">        &#123;</span><br><span class="line">            if( listCURRENT_LIST_LENGTH( &amp;( pxReadyTasksLists[ pxCurrentTCB-&gt;uxPriority ] ) ) &gt; ( UBaseType_t ) 1 )</span><br><span class="line">            &#123;</span><br><span class="line">                xSwitchRequired = pdTRUE;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        #endif /* ( ( configUSE_PREEMPTION == 1 ) &amp;&amp; ( configUSE_TIME_SLICING == 1 ) ) */</span><br><span class="line"></span><br><span class="line">        #if ( configUSE_TICK_HOOK == 1 )</span><br><span class="line">        &#123;</span><br><span class="line">            /* Guard against the tick hook being called when the pended tick</span><br><span class="line">             * count is being unwound (when the scheduler is being unlocked). */</span><br><span class="line">            if( xPendedTicks == ( TickType_t ) 0 )</span><br><span class="line">            &#123;</span><br><span class="line">                vApplicationTickHook();</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        #endif /* configUSE_TICK_HOOK */</span><br><span class="line"></span><br><span class="line">        #if ( configUSE_PREEMPTION == 1 )</span><br><span class="line">        &#123;</span><br><span class="line">            if( xYieldPending != pdFALSE )</span><br><span class="line">            &#123;</span><br><span class="line">                xSwitchRequired = pdTRUE;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        #endif /* configUSE_PREEMPTION */</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        ++xPendedTicks;</span><br><span class="line"></span><br><span class="line">        /* The tick hook gets called at regular intervals, even if the</span><br><span class="line">         * scheduler is locked. */</span><br><span class="line">        #if ( configUSE_TICK_HOOK == 1 )</span><br><span class="line">        &#123;</span><br><span class="line">            vApplicationTickHook();</span><br><span class="line">        &#125;</span><br><span class="line">        #endif</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return xSwitchRequired;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><ol>
<li>首先通过变量uxSchedulerSuspended确认当前调度器是否被挂起，如果挂起则直接将xPendedCounts+1然后退出；</li>
<li>如果未挂起则将xTickCount+1；然后检查tick是否出现溢出，如果tick从0xffffffff增加为0，则会执行<code>taskSWITCH_DELAYED_LISTS</code>，对应代码为:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick</span><br><span class="line"> * count overflows. */</span><br><span class="line">#define taskSWITCH_DELAYED_LISTS()                                                \</span><br><span class="line">    &#123;                                                                             \</span><br><span class="line">        List_t * pxTemp;                                                          \</span><br><span class="line">                                                                                  \</span><br><span class="line">        /* The delayed tasks list should be empty when the lists are switched. */ \</span><br><span class="line">        configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );               \</span><br><span class="line">                                                                                  \</span><br><span class="line">        pxTemp = pxDelayedTaskList;                                               \</span><br><span class="line">        pxDelayedTaskList = pxOverflowDelayedTaskList;                            \</span><br><span class="line">        pxOverflowDelayedTaskList = pxTemp;                                       \</span><br><span class="line">        xNumOfOverflows++;                                                        \</span><br><span class="line">        prvResetNextTaskUnblockTime();                                            \</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>taskSWITCH_DELAYED_LISTS函数功能：</p>
<ul>
<li>将溢出delay任务列表和非溢出delay任务列表做一个对调。</li>
<li>xNumOfOverflows +1，即tick溢出次数加1，用于获知当前的tick已经溢出了多少个循环，可以理解为秒钟走了一圈自动触发分针走一格。</li>
<li>prvResetNextTaskUnblockTime()，将下一个任务的解除阻塞时间重新计算。</li>
</ul>
<p>（我是这么理解的：溢出任务列表里面存放的任务应该是下一个tick循环的任务，而当tick清0并进入新一轮的循环之后，原本的溢出任务列表则变成了非溢出任务列表，可以正常比较执行了。）</p>
<ol start="3">
<li>检查完tick溢出后，通过判断xConstTickCount与xNextTaskUnblockTime的大小关系来确认是否有阻塞的任务出现超时，如果有则将这些任务挨个从pxDelayedTaskList取出放到pxReadyTasksLists，并判断是否有优先级比当前任务相同或更高的任务。如果有（且系统配置了允许优先级抢占configUSE_PREEMPTION）则将xSwitchRequired置为true。</li>
<li>检查当前同一优先级的就绪任务是否超过1个，如果有（且系统配置了允许时间分片configUSE_TIME_SLICING）则将xSwitchRequired置为true。</li>
<li>如果xYieldPending为true，则将xSwitchRequired置为true。xYieldPending是一个全局变量，可以理解为一个异步的任务切换通知，当有些函数希望触发任务切换时，不是直接调用切换，而是通过将xYieldPending置位，然后等到systick中断再切换。</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>xTaskIncrementTick的功能：</p>
<ol>
<li>修改系统tick；</li>
<li>判断是否有任务因为tick增加或是别的原因（xYieldPending）而需要解除阻塞，并修改pxReadyTasksLists和pxDelayedTaskList两个任务列表。</li>
<li>综合是否需要进行任务切换并放到函数返回值中，而真正的切换动作由后续其他函数（xPortPendSVHandler）来完成。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/18/FreeRTOS%E8%BF%9B%E9%98%B6-%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E7%9A%84%E6%97%B6%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WaterYoungMan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WaterYoungMan's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/18/FreeRTOS%E8%BF%9B%E9%98%B6-%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E7%9A%84%E6%97%B6%E6%9C%BA/" class="post-title-link" itemprop="url">FreeRTOS进阶-任务切换的时机</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-18 22:08:49" itemprop="dateCreated datePublished" datetime="2022-08-18T22:08:49+08:00">2022-08-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-08-22 01:06:44" itemprop="dateModified" datetime="2022-08-22T01:06:44+08:00">2022-08-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>操作系统的任务切换是任务管理中很重要的一环。<br>要了解FreeRTOS的任务切换机制，先要了解以下几个函数：</p>
<table>
<thead>
<tr>
<th>描述</th>
<th>FreeRTOS定义中断函数名</th>
<th>ARM芯片常用适配名</th>
</tr>
</thead>
<tbody><tr>
<td>系统管理调用中断</td>
<td>vPortSVCHandler</td>
<td>SVC_Handler</td>
</tr>
<tr>
<td>挂起系统管理中断</td>
<td>xPortPendSVHandler</td>
<td>PendSV_Handler</td>
</tr>
<tr>
<td>系统滴答定时器中断</td>
<td>xPortSysTickHandler</td>
<td>SysTick_Handler</td>
</tr>
<tr>
<td>触发任务切换</td>
<td>taskYIELD</td>
<td>vPortYield</td>
</tr>
</tbody></table>
<p>这4个函数都是是芯片移植FreeRTOS所需要实现的，在不同的芯片架构上有不同的实现方式。<br>前3个函数都是中断函数，需要在芯片启动时候加载到中断向量表中。</p>
<p>在<a target="_blank" rel="noopener" href="https://www.freertos.org/FAQHelp.html">FreeRTOS官方帮助文档</a>中有这样一段描述：</p>
<blockquote>
<p>Special note to ARM Cortex-M users: ARM Cortex-M3, ARM Cortex-M4 and ARM Cortex-M4F ports need FreeRTOS handlers to be installed on the SysTick, PendSV and SVCCall interrupt vectors. The vector table can be populated directly with the FreeRTOS defined xPortSysTickHandler(), xPortPendSVHandler() and vPortSVCHandler() functions respectively, or, if the interrupt vector table is CMSIS compliant, the following three lines can be added to FreeRTOSConfig.h to map the FreeRTOS function names to their CMSIS equivalents:</p>
</blockquote>
<p>即<code>ARM Cortex-M3, ARM Cortex-M4 and ARM Cortex-M4F</code>中才需要将<code>FreeRTOS handlers</code>放到中断向量表中去执行。换而言之，其他芯片调用这些函数时不一定借助中断。</p>
<h2 id="FreeRTOS-任务切换场合"><a href="#FreeRTOS-任务切换场合" class="headerlink" title="FreeRTOS 任务切换场合"></a>FreeRTOS 任务切换场合</h2><ul>
<li>执行系统调用SVC</li>
<li>系统节拍Systick时钟中断</li>
<li>普通任务使用taskYIELD()强制任务切换，中断服务程序中使用portYIELD_FROM_ISR()强制任务切换</li>
</ul>
<p>通过后面的分析我们可以看到，以上的所有任务切换场合最终是通过同一个函数来执行的，也就是中断函数xPortPendSVHandler。</p>
<h2 id="vPortSVCHandler"><a href="#vPortSVCHandler" class="headerlink" title="vPortSVCHandler"></a>vPortSVCHandler</h2><h3 id="谁调用"><a href="#谁调用" class="headerlink" title="谁调用"></a>谁调用</h3><p>xPortStartScheduler()通常在函数 prvStartFirstTask()中通过调用SVC指令触发SVC中断，而第一个任务的启动就是在SVC中断服务函数中完成的。<br>以ARM_CM3为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">	.align 4</span><br><span class="line">vPortStartFirstTask: .asmfunc</span><br><span class="line">	;/* Use the NVIC offset register to locate the stack. */</span><br><span class="line">	ldr r0, NVICOffsetConst</span><br><span class="line">	ldr r0, [r0]</span><br><span class="line">	ldr r0, [r0]</span><br><span class="line">	;/* Set the msp back to the start of the stack. */</span><br><span class="line">	msr msp, r0</span><br><span class="line">	;/* Clear the bit that indicates the FPU is in use in case the FPU was used</span><br><span class="line">	;before the scheduler was started - which would otherwise result in the</span><br><span class="line">	;unnecessary leaving of space in the SVC stack for lazy saving of FPU</span><br><span class="line">	;registers. */</span><br><span class="line">	mov r0, #0</span><br><span class="line">	msr control, r0</span><br><span class="line">	;/* Call SVC to start the first task. */</span><br><span class="line">	cpsie i</span><br><span class="line">	cpsie f</span><br><span class="line">	dsb</span><br><span class="line">	isb</span><br><span class="line">	svc #0</span><br><span class="line">	.endasmfunc</span><br></pre></td></tr></table></figure>
<p>值得注意的是，并不是所有的芯片架构的prvStartFirstTask都是通过SVC中断来启动第一个任务，我们看下ARM_CM0的代码，里面没有”svc #0”语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void vPortStartFirstTask( void )</span><br><span class="line">&#123;</span><br><span class="line">    /* The MSP stack is not reset as, unlike on M3/4 parts, there is no vector</span><br><span class="line">     * table offset register that can be used to locate the initial stack value.</span><br><span class="line">     * Not all M0 parts have the application vector table at address 0. */</span><br><span class="line">    __asm volatile (</span><br><span class="line">        &quot;	.syntax unified				\n&quot;</span><br><span class="line">        &quot;	ldr  r2, pxCurrentTCBConst2	\n&quot;/* Obtain location of pxCurrentTCB. */</span><br><span class="line">        &quot;	ldr  r3, [r2]				\n&quot;</span><br><span class="line">        &quot;	ldr  r0, [r3]				\n&quot;/* The first item in pxCurrentTCB is the task top of stack. */</span><br><span class="line">        &quot;	adds r0, #32					\n&quot;/* Discard everything up to r0. */</span><br><span class="line">        &quot;	msr  psp, r0					\n&quot;/* This is now the new top of stack to use in the task. */</span><br><span class="line">        &quot;	movs r0, #2					\n&quot;/* Switch to the psp stack. */</span><br><span class="line">        &quot;	msr  CONTROL, r0				\n&quot;</span><br><span class="line">        &quot;	isb							\n&quot;</span><br><span class="line">        &quot;	pop  &#123;r0-r5&#125;					\n&quot;/* Pop the registers that are saved automatically. */</span><br><span class="line">        &quot;	mov  lr, r5					\n&quot;/* lr is now in r5. */</span><br><span class="line">        &quot;	pop  &#123;r3&#125;					\n&quot;/* Return address is now in r3. */</span><br><span class="line">        &quot;	pop  &#123;r2&#125;					\n&quot;/* Pop and discard XPSR. */</span><br><span class="line">        &quot;	cpsie i						\n&quot;/* The first task has its context and interrupts can be enabled. */</span><br><span class="line">        &quot;	bx   r3						\n&quot;/* Finally, jump to the user defined task code. */</span><br><span class="line">        &quot;								\n&quot;</span><br><span class="line">        &quot;	.align 4					\n&quot;</span><br><span class="line">        &quot;pxCurrentTCBConst2: .word pxCurrentTCB	  &quot;</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从<code>FreeRTOS/Source/portable</code>中可以看到，在不同芯片上，SVC调用代码还可以是<code>svc %0</code>或<code>svc 0</code></p>
<h3 id="发生了什么"><a href="#发生了什么" class="headerlink" title="发生了什么"></a>发生了什么</h3><p>该中断的优先级为1，由SVC指令触发。触发后如果没有更高优先级的中断存在，就会根据中断向量表，跳转到vPortSVCHandler函数。</p>
<h3 id="为什么要设计SVC中断"><a href="#为什么要设计SVC中断" class="headerlink" title="为什么要设计SVC中断"></a>为什么要设计SVC中断</h3><p>SVC中断中需要修改寄存器，根据一些网上的资料，在部分ARM芯片上，只有特权模式下才能修改这些寄存器，而进入中断会自动切换到特权模式。因此我怀疑这个SVC的设计和ARM的权限设计有关，即用户模式下的应用需要借助高权限的中断来完成一些操作系统任务。</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>以ARM_CM3为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void vPortSVCHandler( void )</span><br><span class="line">&#123;</span><br><span class="line">    __asm volatile (</span><br><span class="line">        &quot;	ldr	r3, pxCurrentTCBConst2		\n&quot;/* Restore the context. */</span><br><span class="line">        &quot;	ldr r1, [r3]					\n&quot;/* Use pxCurrentTCBConst to get the pxCurrentTCB address. */</span><br><span class="line">        &quot;	ldr r0, [r1]					\n&quot;/* The first item in pxCurrentTCB is the task top of stack. */</span><br><span class="line">        &quot;	ldmia r0!, &#123;r4-r11&#125;				\n&quot;/* Pop the registers that are not automatically saved on exception entry and the critical nesting count. */</span><br><span class="line">        &quot;	msr psp, r0						\n&quot;/* Restore the task stack pointer. */</span><br><span class="line">        &quot;	isb								\n&quot;</span><br><span class="line">        &quot;	mov r0, #0 						\n&quot;</span><br><span class="line">        &quot;	msr	basepri, r0					\n&quot;</span><br><span class="line">        &quot;	orr r14, #0xd					\n&quot;</span><br><span class="line">        &quot;	bx r14							\n&quot;</span><br><span class="line">        &quot;									\n&quot;</span><br><span class="line">        &quot;	.align 4						\n&quot;</span><br><span class="line">        &quot;pxCurrentTCBConst2: .word pxCurrentTCB				\n&quot;</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="xPortPendSVHandler"><a href="#xPortPendSVHandler" class="headerlink" title="xPortPendSVHandler"></a>xPortPendSVHandler</h2><h3 id="为什么要设计PendSV中断"><a href="#为什么要设计PendSV中断" class="headerlink" title="为什么要设计PendSV中断"></a>为什么要设计PendSV中断</h3><p>SV 的全称是 Supervisor，翻译为“监督者”，指的是系统管理。<br>PendSV中断服务程序的功能是完成任务切换。即找到最高优先级的就绪任务，然后让这个任务接下来能获得CPU运行权。<br>不在Systick中执行任务切换，是为了避免任务切换占用太多了时间，导致其他中断阻塞。<br>PendSV的优先级为最低，也就是说如果有其他更高优先级的中断，则需要将其他中断执行完之后再执行xPortPendSVHandler，为什么这么设计呢？因为中断的优先级大于所有任务。而任务切换的最终结果只是去决定下一个执行的任务是哪个，那么自然中断切换的优先级应该放到所有中断的最低档，却又比所有的任务优先级高。。</p>
<h3 id="PendSV中断如何触发"><a href="#PendSV中断如何触发" class="headerlink" title="PendSV中断如何触发"></a>PendSV中断如何触发</h3><p>PendSV可以由xPortSysTickHandler或vPortSVCHandler触发</p>
<h2 id="xPortSysTickHandler"><a href="#xPortSysTickHandler" class="headerlink" title="xPortSysTickHandler"></a>xPortSysTickHandler</h2><p>在系统节拍时钟中断服务函数中:<br>首先会将tick计数器的值+1，同时查看是否有任务解除阻塞，如果有任务解除阻塞的话，则使能PendSV中断。<br>以ARM_CM3为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void xPortSysTickHandler( void )</span><br><span class="line">&#123;</span><br><span class="line">    /* The SysTick runs at the lowest interrupt priority, so when this interrupt</span><br><span class="line">     * executes all interrupts must be unmasked.  There is therefore no need to</span><br><span class="line">     * save and then restore the interrupt mask value as its value is already</span><br><span class="line">     * known. */</span><br><span class="line">    portDISABLE_INTERRUPTS();</span><br><span class="line">    &#123;</span><br><span class="line">        /* Increment the RTOS tick. */</span><br><span class="line">        if( xTaskIncrementTick() != pdFALSE )</span><br><span class="line">        &#123;</span><br><span class="line">            /* A context switch is required.  Context switching is performed in</span><br><span class="line">             * the PendSV interrupt.  Pend the PendSV interrupt. */</span><br><span class="line">            portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    portENABLE_INTERRUPTS();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="taskYIELD"><a href="#taskYIELD" class="headerlink" title="taskYIELD"></a>taskYIELD</h2><p>在需要手动切换任务的场景，就会调用taskYIELD()，最终会执行宏portYIELD()。<br>以ARM_CM3为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#define portYIELD()                                 \</span><br><span class="line">&#123;                                                   \</span><br><span class="line">    /* Set a PendSV to request a context switch. */ \</span><br><span class="line">    portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT; \</span><br><span class="line">                                                    \</span><br><span class="line">    /* Barriers are normally not required but do ensure the code is completely \</span><br><span class="line">     * within the specified behaviour for the architecture. */ \</span><br><span class="line">    __asm volatile ( &quot;dsb&quot; ::: &quot;memory&quot; );                     \</span><br><span class="line">    __asm volatile ( &quot;isb&quot; );                                  \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在tasks.c中可以看到，xTaskResumeAll、vTaskResume、prvIdleTask这样的函数都会调用taskYIELD。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>systick中断、任务操作函数、某些系统调用都会触发任务切换。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">WaterYoungMan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">WaterYoungMan</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
